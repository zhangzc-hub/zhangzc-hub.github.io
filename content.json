{"meta":{"title":"ZC程序员","subtitle":"解码技术与生活的奥秘","description":"这里是 ZC 的技术博客，一名热爱编程的程序员，分享技术心得和个人生活感悟。让我们一起在代码的海洋中遨游，感受技术与生活的美妙交响。","author":"ZZC","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-11-26T00:30:44.002Z","updated":"2024-11-26T00:30:44.002Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"技术与梦想的交汇点 —— 我的故事大家好，欢迎来到我的小天地！我是ZC，一名对科技充满热情的探索者。在这个日新月异的时代，我坚信技术不仅仅是工具，更是改变世界的力量。今天，我想与大家分享我的旅程，以及那些激励我前行的故事。 一、起点我的故事始于一个普通的小城市。从小我就对电子设备充满了好奇，经常拆解家里的收音机、遥控器等，试图了解它们是如何工作的。这份好奇心随着年龄的增长而愈发强烈，最终引领我走上了计算机科学的道路。 二、求学之路大学时期，我选择了计算机科学作为我的专业。在校园里，我不仅学到了编程的基础知识，更重要的是，我学会了如何思考问题、解决问题。参与各类项目比赛的经历让我意识到，团队合作与创新思维同样重要。这些宝贵的经验为我后来的职业生涯打下了坚实的基础。 三、职业发展毕业后，我加入了一家知名的互联网公司，担任软件工程师一职。在这里，我有幸参与到多个大型项目的开发中，见证了从概念设计到产品上线的全过程。这段经历极大地拓宽了我的视野，也加深了我对技术变革社会潜力的认识。 随着时间的推移，我逐渐意识到，仅仅作为一名开发者并不足以满足我对世界的渴望。我渴望将自己的想法与更多人分享，于是决定开设这个博客，希望能够成为一个连接技术与人文的桥梁。 四、创建博客创建这个博客的目的很简单：分享知识、激发灵感、促进交流。我希望通过撰写技术文章、行业观察以及个人感悟，不仅能够帮助读者解决实际问题，更能激发他们对未来的想象。我相信，每个人都有潜力成为改变世界的一份子。 五、展望未来未来，我将继续走在技术的前沿，不断学习新的知识和技术。同时，我也希望通过这个平台，与更多的志同道合者相遇，共同探讨技术如何更好地服务于人类社会。无论前方道路如何变化，我都将保持初心，勇敢前行。 感谢每一位访问者，因为有了你们的支持与陪伴，这段旅程才更加精彩。期待在未来的日子里，我们能够一起见证更多的奇迹发生。"},{"title":"所有标签","date":"2024-11-25T11:22:46.949Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-11-25T11:22:55.110Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2024-11-25T11:23:05.900Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"cfssl工具制作证书","slug":"cfssl工具制作证书","date":"2025-07-01T05:35:02.000Z","updated":"2025-08-01T08:28:15.871Z","comments":true,"path":"2025/07/01/cfssl工具制作证书/","permalink":"http://example.com/2025/07/01/cfssl%E5%B7%A5%E5%85%B7%E5%88%B6%E4%BD%9C%E8%AF%81%E4%B9%A6/","excerpt":"","text":"cfssl工具制作证书安装cfssl[去git下载二进制文件]: https://github.com/cloudflare/cfssl/releases “点击下载文件” 下载文件 1cfssl_1.6.5_linux_amd64 cfssl-certinfo_1.6.5_linux_amd64 cfssljson_1.6.5_linux_amd64 123456# 赋权限$ chmod +x cffs*# 移动到 /usr/local/bin$ mv cfssl_1.6.1_linux_amd64 /usr/local/bin/cfssl$ mv cfssl-certinfo_1.6.1_linux_amd64 /usr/local/bin/cfssl-certinfo$ mv cfssljson_1.6.1_linux_amd64 /usr/local/bin/cfssljson 生成根证书12345678910111213141516171819202122# 根证书请求配置文件$ vim ca-csr.json&#123; &quot;CN&quot;: &quot;ltdw&quot;, &quot;key&quot;: &#123; &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 &#125;, &quot;names&quot;: [&#123; &quot;C&quot;: &quot;CN&quot;, &quot;ST&quot;: &quot;Beijing&quot;, &quot;L&quot;: &quot;beijing&quot;, &quot;O&quot;: &quot;ltdw&quot;, &quot;OU&quot;: &quot;ltdw&quot; &#125;]&#125;# 生成证书$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca# -base ca 指定生成的证书名称 CN 证书名称 C Country， 国家 L Locality，地区，城市 O Organization Name，组织名称，公司名称 OU Organization Unit Name，组织单位名称，公司部门 ST State，州，省 通过ca签发服务器证书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 服务器证书请求配置文件vim 192.168.1.101-csr.json&#123; &quot;CN&quot;: &quot;192.168.1.101&quot;, &quot;hosts&quot;: [ &quot;192.168.1.101&quot;, &quot;kube-master&quot; ], &quot;key&quot;: &#123; &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 &#125;, &quot;names&quot;: [ &#123; &quot;C&quot;: &quot;CN&quot;, &quot;L&quot;: &quot;BeiJing&quot;, &quot;ST&quot;: &quot;BeiJing&quot;, &quot;O&quot;: &quot;ltdw&quot;, &quot;OU&quot;: &quot;ltdw&quot; &#125; ]&#125;# 生成证书策略文件$ cat ca-config.json&#123; &quot;signing&quot;: &#123; &quot;default&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot; &#125;, &quot;profiles&quot;: &#123; &quot;server&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;server auth&quot;, &quot;client auth&quot; ] &#125;, &quot;intermediate&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;cert sign&quot;, &quot;crl sign&quot;, &quot;server auth&quot;, &quot;client auth&quot; ] &#125; &#125; &#125;&#125;# 生成证书$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=intermediate 192.168.1.101-csr.json | cfssljson -bare 192.168.1.101# 单独生成csr文件$ cfssl genkey csr.json | cfssljson -bare 192.168.1.101# 证书和私钥合并成pfx$ openssl pkcs12 -export -out certificate.pfx -inkey private_key.pem -in certificate.pem -certfile intermediate_cert.pem# pfx 提取证书和私钥$ openssl pkcs12 -in certificate.pfx -nocerts -nodes -out private_key.pem$ openssl pkcs12 -in certificate.pfx -clcerts -nokeys -out certificate.pem$ openssl verify -CAfile ca.pem intermediate.pem 默认策略，指定了证书的有效期是一年(8760h) usages.signing, 表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA&#x3D;TRUE usages.server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证 usages.client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证 证书格式转换12345# pem &gt; crt$ openssl x509 -in ca.pem -out ca.crt# pem &gt; key$ openssl rsa -in ca.pem -out ca.key 挂载在Linux操作系统中, 把192.168.1.101-key.pem和192.168.1.101.pem 挂载到nginx下 本地计算机安装ca.crt证书 双击-安装证书-本地计算机-将所有证书都放入下列存储-受信任的根证书颁发机构","categories":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/categories/ssl/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"}]},{"title":"yuque-dl","slug":"yuque-dl","date":"2025-05-21T06:59:27.000Z","updated":"2025-05-21T07:08:37.340Z","comments":true,"path":"2025/05/21/yuque-dl/","permalink":"http://example.com/2025/05/21/yuque-dl/","excerpt":"","text":"语雀文档下载到本地1.下载nodejs 点此直接下载Node.js v22.13.1 去官网查看： 1https://nodejs.org/zh-cn 2.win+r打开运行，输入cmd打开命令提示符 3.更换镜像源 12npm config get registry npm config set registry https://registry.npmmirror.com 4.安装插件 1npm i -g yuque-dl 5.查看是否下载完成 1yuque-dl --help 6.下载文档 yuque-dl 示例： 1yuque-dl &quot;https://www.yuque.com/yuque/thyzgp&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 修改默认路径 在cmd里输入以下命令 mklink&#x2F;J “C:\\Users\\你的用户名\\download” “目标位置” 例如： 1mklink/J &quot;C:\\Users\\hp\\download&quot; &quot;D:\\download&quot; 当显示：为xxx&lt;&lt;&#x3D;&#x3D;&#x3D;&gt;&gt;xxx创建的连接即可 然后正常下载 7、出现下面图片中报错的情况的，按下面的方法解决 私有知识库通过别人私有知识库 分享的链接，需使用-t添加token才能下载 1yuque-dl &quot;https://www.yuque.com/yuque/thyzgp&quot; -t &quot;abcd...&quot; 公开密码访问的知识库⚠️ 公开密码访问的知识库两种情况: 已经登录语雀，访问需要密码的知识库 输入密码后使用_yuque_session这个cookie 1yuque-dl &quot;url&quot; -t &quot;_yuque_session的值&quot; 未登录语雀，访问需要密码的知识库 输入密码后需要使用verified_books&#x2F;verified_docs这个cookie 1yuque-dl &quot;url&quot; -k &quot;verified_books&quot; -t &quot;verified_books的值&quot; 内置启动web服务可快速预览使用vitepress快速启动一个web服务提供可预览下载的内容 1234yuque-dl server ./download/知识库/➜ Local: http://localhost:5173/➜ Network: use --host to expose","categories":[{"name":"cmd","slug":"cmd","permalink":"http://example.com/categories/cmd/"}],"tags":[{"name":"语雀","slug":"语雀","permalink":"http://example.com/tags/%E8%AF%AD%E9%9B%80/"}]},{"title":"Redis集群搭建","slug":"Redis集群搭建","date":"2025-03-20T06:36:00.000Z","updated":"2025-03-20T11:59:22.809Z","comments":true,"path":"2025/03/20/Redis集群搭建/","permalink":"http://example.com/2025/03/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Redis集群搭建1、Redis主从集群1.1、集群结构搭建的主从集群结构如图： 共包含三个节点，一个主节点，两个从节点。 在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 slave 192.168.150.101 7003 slave 1.2、准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 1）创建目录 创建三个文件夹，名字分别叫7001、7002、7003： 1234# 进入/tmp目录cd /tmp# 创建目录mkdir 7001 7002 7003 2）恢复原始配置 修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。 12345678# 开启RDB# save &quot;&quot;save 3600 1save 300 100save 60 10000# 关闭AOFappendonly no 3）拷贝配置文件到每个实例目录 然后将redis-6.2.4&#x2F;redis.conf文件拷贝到三个目录中（在&#x2F;tmp目录执行下列命令）： 123456# 方式一：逐个拷贝cp redis-6.2.4/redis.conf 7001cp redis-6.2.4/redis.conf 7002cp redis-6.2.4/redis.conf 7003# 方式二：管道组合命令，一键拷贝echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 4）修改每个实例的端口、工作目录 修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在&#x2F;tmp目录执行下列命令）： 123sed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7001\\//g&#x27; 7001/redis.confsed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7002\\//g&#x27; 7002/redis.confsed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7003\\//g&#x27; 7003/redis.conf 5）修改每个实例的声明IP 虚拟机本身有多个IP，为了避免将来混乱，需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下： 12# redis实例的声明 IPreplica-announce-ip 192.168.150.101 每个目录都要改，我们一键完成修改（在&#x2F;tmp目录执行下列命令）： 1234567# 逐一执行sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7001/redis.confsed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7002/redis.confsed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7003/redis.conf# 或者一键修改printf &#x27;%s\\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; &#123;&#125;/redis.conf 1.3、启动12345678910# 第1个redis-server 7001/redis.conf# 第2个redis-server 7002/redis.conf# 第3个redis-server 7003/redis.conf或./redis-6.2.4/src/redis-server ./7001/redis.conf./redis-6.2.4/src/redis-server ./7002/redis.conf./redis-6.2.4/src/redis-server ./7003/redis.conf 启动后： 12# 如果要一键停止，可以运行下面命令：printf &#x27;%s\\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 1.4、开启主从关系现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。 有临时和永久两种模式： 修改配置文件（永久生效） slaveof 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）： 1slaveof &lt;masterip&gt; &lt;masterport&gt; 注意：在5.0以后新增命令replicaof，与salveof效果一致。 这里我们为了演示方便，使用方式二。 通过redis-cli命令连接7002，执行下面命令： 1234# 连接 7002redis-cli -p 7002# 执行slaveofslaveof 124.183.178.142 7001 通过redis-cli命令连接7003，执行下面命令： 1234# 连接 7003redis-cli -p 7003# 执行slaveofslaveof 192.168.150.101 7001 然后连接 7001节点，查看集群状态： 1234# 连接 7001redis-cli -p 7001# 查看状态info replication 结果： 1.5、测试执行下列操作以测试： 利用redis-cli连接7001，执行 1set num 123 利用redis-cli连接7002，执行 12get num，再执行set num 666 利用redis-cli连接7003，执行 12get num，再执行set num 888 可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。 2、搭建哨兵集群2.1、集群结构这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图： 三个sentinel实例信息如下： 节点 IP PORT s1 192.168.150.101 27001 s2 192.168.150.101 27002 s3 192.168.150.101 27003 3.2.准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 我们创建三个文件夹，名字分别叫s1、s2、s3： 1234# 进入/tmp目录cd /tmp# 创建目录mkdir s1 s2 s3 然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容： 123456port 27001sentinel announce-ip 192.168.150.101sentinel monitor mymaster 192.168.150.101 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir &quot;/tmp/s1&quot; 解读： port 27001 ：是当前sentinel实例的端口 sentinel monitor mymaster 192.168.150.101 7001 2 ：指定主节点信息 mymaster ：主节点名称，自定义，任意写 192.168.150.101 7001 ：主节点的ip和端口 2 ：选举master时的quorum值 然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）： 12345# 方式一：逐个拷贝cp s1/sentinel.conf s2cp s1/sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf 修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003： 12sed -i -e &#x27;s/27001/27002/g&#x27; -e &#x27;s/s1/s2/g&#x27; s2/sentinel.confsed -i -e &#x27;s/27001/27003/g&#x27; -e &#x27;s/s1/s3/g&#x27; s3/sentinel.conf 2.3、启动为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： 123456789# 第1个redis-sentinel s1/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s1/sentinel.conf# 第2个redis-sentinel s2/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s2/sentinel.conf# 第3个redis-sentinel s3/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s3/sentinel.conf 启动后： 2.3、测试尝试让master节点7001宕机，查看sentinel日志： 查看7003的日志： 查看7002的日志： 3、搭建分片集群3.1、集群结构分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下： 这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 master 192.168.150.101 7003 master 192.168.150.101 8001 slave 192.168.150.101 8002 slave 192.168.150.101 8003 slave 3.2、准备实例和配置删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录： 123456# 进入/tmp目录cd /tmp# 删除旧的，避免配置干扰rm -rf 7001 7002 7003# 创建目录mkdir 7001 7002 7003 8001 8002 8003 在&#x2F;tmp下准备一个新的redis.conf文件，内容如下： 123456789101112131415161718192021port 6379# 开启集群功能cluster-enabled yes# 集群的配置文件名称，不需要我们创建，由redis自己维护cluster-config-file /tmp/6379/nodes.conf# 节点心跳失败的超时时间cluster-node-timeout 5000# 持久化文件存放目录dir /tmp/6379# 绑定地址bind 0.0.0.0# 让redis后台运行,守护进程daemonize yes# 注册的实例ipreplica-announce-ip 192.168.150.101# 保护模式protected-mode no# 数据库数量databases 1# 日志logfile /tmp/6379/run.log 将这个文件拷贝到每个目录下： 1234# 进入/tmp目录cd /tmp# 执行拷贝echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf 修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致： 1234# 进入/tmp目录cd /tmp# 修改配置文件printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i &#x27;s/6379/&#123;&#125;/g&#x27; &#123;&#125;/redis.conf 3.3、启动因为已经配置了后台启动模式，所以可以直接启动服务： 1234# 进入/tmp目录cd /tmp# 一键启动所有服务printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf 通过ps查看状态： 1ps -ef | grep redis 发现服务都已经正常启动： 如果要关闭所有进程，可以执行命令： 1ps -ef | grep redis | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill 或者（推荐这种方式）： 1printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 3.4、创建集群虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。 我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。 1）Redis5.0之前 Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。 123# 安装依赖yum -y install zlib ruby rubygemsgem install redis 然后通过命令来管理集群： 1234# 进入redis的src目录cd /tmp/redis-6.2.4/src# 创建集群./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 2）Redis5.0以后 我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下： 1redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 命令说明： redis-cli –cluster 或者 .&#x2F;redis-trib.rb：代表集群操作命令 create ：代表是创建集群 –replicas 1 或者 –cluster-replicas 1 ：指定集群中每个master的副本个数为1，此时 节点总数 ÷ (replicas + 1) 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master 运行后的样子： 这里输入yes，则集群开始创建： 通过命令可以查看集群状态： 1redis-cli -p 7001 cluster nodes 3.5、测试尝试连接7001节点，存储一个数据： 12345678# 连接redis-cli -p 7001# 存储数据set num 123# 读取数据get num# 再次存储set a 1 结果悲剧了： 集群操作时，需要给redis-cli加上-c参数才可以： 1redis-cli -c -p 7001 这次可以了：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"SpringCache框架的使用","slug":"SpringCache框架的使用","date":"2024-08-08T02:27:30.000Z","updated":"2025-08-08T02:39:29.594Z","comments":true,"path":"2024/08/08/SpringCache框架的使用/","permalink":"http://example.com/2024/08/08/SpringCache%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SpringCache框架的使用1、注解 注解 说明 @EnableCaching 开启缓存注解功能 @Cacheable 在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 @CachePut 将方法的返回值放到缓存中 @CacheEvict 将一条或多条数据从缓存中删除 2、导入坐标使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 123456789spring: redis: host: 192.168.200.200 port: 6379 password: root@123456 database: 0 cache: redis: time-to-live: 1800000 #设置缓存过期时间，可选 3、注解应用@CachePut注解@CachePut 说明： ​ 作用: 将方法返回值，放入缓存 ​ value: 缓存的名称, 每个缓存名称下面可以有很多key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 1234567891011/*** CachePut：将方法返回值放入缓存* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)@PostMappingpublic User save(User user)&#123; userService.save(user); return user;&#125; key的写法如下： ​ #user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ; ​ #user.name: #user指的是方法形参的名称, name指的是user的name属性 ,也就是使用user的name属性作为key ; ​ #result.id : #result代表方法返回值，该表达式 代表以返回对象的id属性作为key ； ​ #result.name : #result代表方法返回值，该表达式 代表以返回对象的name属性作为key ； @CacheEvict注解@CacheEvict 说明： ​ 作用: 清理指定缓存 ​ value: 缓存的名称，每个缓存名称下面可以有多个key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 123456789101112131415161718192021222324/*** CacheEvict：清理指定缓存* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0&quot;) //#p0 代表第一个参数//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;) //#root.args[0] 代表第一个参数//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#id&quot;) //#id 代表变量名为id的参数@DeleteMapping(&quot;/&#123;id&#125;&quot;)public void delete(@PathVariable Long id)&#123; userService.removeById(id);&#125;//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0.id&quot;) //第一个参数的id属性//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#user.id&quot;) //参数名为user参数的id属性//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0].id&quot;) //第一个参数的id属性@CacheEvict(value = &quot;userCache&quot;,key = &quot;#result.id&quot;) //返回值的id属性@PutMappingpublic User update(User user)&#123; userService.updateById(user); return user;&#125; @Cacheable注解@Cacheable 说明: ​ 作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 ​ value: 缓存的名称，每个缓存名称下面可以有多个key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 1234567891011/*** Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)public User getById(@PathVariable Long id)&#123; User user = userService.getById(id); return user;&#125; 在@Cacheable注解中，提供了两个属性分别为： condition， unless 。 condition : 表示满足什么条件, 再进行缓存 ; unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ; 12345678910111213/** * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 * value：缓存的名称，每个缓存名称下面可以有多个key * key：缓存的key * condition：条件，满足条件时才缓存数据 * unless：满足条件则不缓存 */@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;, unless = &quot;#result == null&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)public User getById(@PathVariable Long id)&#123; User user = userService.getById(id); return user;&#125; 在list方法上加注解@Cacheable 在list方法中进行查询时，有两个查询条件，如果传递了id，根据id查询； 如果传递了name， 根据name查询，那么我们缓存的key在设计的时候，就需要既包含id，又包含name。 具体的代码实现如下： 123456789@Cacheable(value = &quot;userCache&quot;,key = &quot;#user.id + &#x27;_&#x27; + #user.name&quot;)@GetMapping(&quot;/list&quot;)public List&lt;User&gt; list(User user)&#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(user.getId() != null,User::getId,user.getId()); queryWrapper.eq(user.getName() != null,User::getName,user.getName()); List&lt;User&gt; list = userService.list(queryWrapper); return list;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"使用yum安装wget报错","slug":"使用yum安装wget报错","date":"2024-01-13T08:42:09.000Z","updated":"2025-03-20T07:15:24.315Z","comments":true,"path":"2024/01/13/使用yum安装wget报错/","permalink":"http://example.com/2024/01/13/%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85wget%E6%8A%A5%E9%94%99/","excerpt":"","text":"使用yum安装wget报错使用yum安装报错：Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp; 安装wget命令 1yum -y install wget 报错，无法找到镜像 测试是否是网络问题 抓包正常，网络没有问题；尝试更新yum 又开始报错 尝试分析问题原因出现这个错误是因为使用的 CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了你的 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。 尝试解决： 进入&#x2F;etc&#x2F;yum.repos.d目录下找到 CentOS-Base.rep 执行下面操作 1cp CentOS-Base.repo CentOS-Base.repo.backup 然后修改 CentOS-Base.repo 为 # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/os/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #released updates [updates] name=CentOS-$releasever - Updates #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra #$baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 wq保存，再执行 12sudo yum clean allsudo yum makecache 等待加载成功，然后继续执行 1curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 然后执行 1cat CentOS-Base.repo 发现镜像已改为了阿里云的 再此尝试导入wget命令 好的成功了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"}]},{"title":"CentOS安装Docker\\Docker-compose","slug":"CentOS安装Docker","date":"2023-12-19T05:53:20.000Z","updated":"2025-03-20T11:59:11.471Z","comments":true,"path":"2023/12/19/CentOS安装Docker/","permalink":"http://example.com/2023/12/19/CentOS%E5%AE%89%E8%A3%85Docker/","excerpt":"","text":"CentOS安装Docker\\Docker-composeCentOS安装Docker1、卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 2、安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678910# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #将所有的 download.docker.com 替换为 mirrors.aliyun.com/docker-cesed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo#输入以下命令来更新 yum 缓存yum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 3、启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。 这里展示直接关闭防火墙的命令 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 123456789systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务systemctl enable docker # 开机自启docker服务systemctl start docker # 启动docker服务 然后输入命令，可以查看docker版本： 1docker -v 4、配置镜像加速docker官方镜像仓库网速较差，导致拉取镜像失败，如下面这种错误， 1docker pull 报错 Error response from daemon: Get “https://registry-1.docker.io/v2/“ 我们需要设置国内镜像服务： 解决方案如下： 1vi /etc/docker/daemon.json 添加以下内容： 1234567&#123; &quot;data-root&quot;: &quot;/home/docker-root&quot;, &quot;registry-mirrors&quot;: [ &quot;https://registry.dockercn.com&quot;, &quot;https://0mmuy3ea.mirror.aliyuncs.com/&quot;,&quot;https://docker.m.daocloud.io/&quot; ]&#125; 然后保存 1:wq 重启docker 12systemctl daemon-reloadsystemctl restart docker centos安装docker-compose1、最新版本查询Docker Compose 的最新版本会不断更新，你可以通过以下几种方式来查看目前的最新版本： 官方发布页面：访问 Docker Compose 的 GitHub 发布页面，该页面会列出所有的版本信息，页面上显示的最新版本就是目前可获取的最新版本。 命令行查看：如果你已经安装了 Docker Compose，在终端中执行 docker-compose version 命令，就能看到当前安装的版本。要是想知道是否有更新版本，还是要参考官方发布页面。 2、安装最新版本如果要安装最新版本的 Docker Compose，可以参考以下步骤（以 Linux 系统为例）： 1234567891011# 获取最新稳定版本号COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep &#x27;tag_name&#x27; | cut -d\\&quot; -f4)# 下载指定版本的 Docker Composesudo curl -L &quot;https://github.com/docker/compose/releases/download/$&#123;COMPOSE_VERSION&#125;/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 添加可执行权限sudo chmod +x /usr/local/bin/docker-compose# 验证安装docker-compose --version 上述脚本会自动获取最新版本号并完成 Docker Compose 的下载和安装，最后验证安装是否成功。 3、获取最新版本补全脚本若要使用最新版本的 Docker Compose 补全脚本，你可以把命令中的版本号替换成最新版本。获取最新版本号的方式有多种，例如访问 Docker Compose 的 GitHub 发布页面。 假设你已经得知最新版本是 v2.20.3（实际使用时请替换为真正的最新版本），可以使用如下命令获取对应版本的补全脚本： 1sudo curl -L https://raw.githubusercontent.com/docker/compose/v2.20.3/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 运行完该命令后，重新打开一个终端让补全功能生效。 4、当使用命令无法安装时，可以下载源文件进行安装，步骤如下：当你下载了 compose-2.34.0.tar.gz 文件后，通常意味着你下载的是 Docker Compose 的源码包，下面为你介绍安装 Docker Compose 的操作步骤： 1. 解压文件你需要使用 tar 命令来解压下载的 compose-2.34.0.tar.gz 文件。在终端中执行以下命令： bash 1tar -zxvf compose-2.34.0.tar.gz 该命令会将压缩包解压到当前目录下，解压后会生成一个名为 compose-2.34.0 的文件夹。 2. 进入解压后的目录使用 cd 命令进入解压后的文件夹： bash 1cd compose-2.34.0 3. 构建并安装 Docker Compose一般情况下，你可以使用 make 命令来构建和安装 Docker Compose。不过在执行 make 命令之前，需要确保你的系统已经安装了 make 工具和其他必要的依赖项。执行以下命令： bash 12makesudo make install make 命令会根据 Makefile 文件中的规则来编译和构建 Docker Compose。 sudo make install 命令会将构建好的二进制文件安装到系统中，使其可以在全局范围内使用。 4. 验证安装安装完成后，你可以使用以下命令来验证 Docker Compose 是否安装成功： bash 1docker-compose --version 如果输出显示 Docker Compose 的版本为 2.34.0，则说明安装成功。 可能遇到的问题及解决办法 缺少依赖项：如果在执行 make 命令时出现错误，提示缺少某些依赖项，你需要安装这些依赖项。常见的依赖项包括 go 语言环境等。你可以根据错误提示安装相应的依赖项。 权限问题：如果在执行 sudo make install 命令时遇到权限问题，确保你具有足够的权限。通常使用 sudo 命令可以解决权限问题。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"hexo搭建博客","slug":"博客制作","date":"2023-11-25T10:48:45.000Z","updated":"2025-03-20T11:59:32.122Z","comments":true,"path":"2023/11/25/博客制作/","permalink":"http://example.com/2023/11/25/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C/","excerpt":"","text":"hexo搭建博客第一部分Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。 Windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 Linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用git --version 来查看一下版本 2. 安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3. 安装hexo****前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 ** _config.yml: 博客的配置文件** 12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。 点击create repository。 5. 生成SSH添加到GitHub回到你的git bash中， 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 12git config user.namegit config user.email 然后创建SSH,一路回车 1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 1ssh -T git@github.com 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后 123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 接下来你就可以正式开始写文章了。 1hexo new newpapername 然后在source&#x2F;_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再 123hexo cleanhexo ghexo d 就可以看到更新了。 第二部分hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。 1. hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。网址 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。 再往下翻，中间这些都默认就好了。 12345678theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games layout（布局）当你每一次使用代码 1hexo new paper 它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 而new这个命令其实是： 1hexo new [layout] &lt;title&gt; 只不过这个layout默认是post罢了。 page如果你想另起一页，那么可以使用 1hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是http://xxx.xxx/board draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source&#x2F;_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 2. 更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里 直接在github链接上下载下来，然后放到theme文件夹下就行了，然后再在刚才说的配置文件中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。 而后进入hueman这个文件夹，可以看到里面也有一个配置文件_config.xml，貌似它默认是_config.xml.example，把它复制一份，重命名为_config.xml就可以了。这个配置文件是修改你整个主题的配置文件。 3. git分支进行多终端工作问题来了，如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？ 在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 机制机制是这样的，由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。 也就是上传的是在本地目录里自动生成的.deploy_git里面。 其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github 所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 上传分支首先，先在github上新建一个hexo分支，如图： 然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。 然后在本地的任意目录下，打开git bash， 1git clone git@github.com:xxxxx-hub/xxxxxx.github.io.git 将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。 接下来在克隆到本地的ZJUFangzh.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。 而后 123git add .git commit –m &quot;add branch&quot;git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 这样就上传完了。 更换电脑操作一样的，跟之前的环境搭建一样， 安装git 1sudo apt-get install git 设置git全局邮箱和用户名 12git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot; 设置ssh key 12345ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话) 安装nodejs 12sudo apt-get install nodejssudo apt-get install npm 安装hexo 1sudo npm install hexo-cli -g 但是已经不需要初始化了， 直接在任意文件夹下， 1git clone git@……………… 然后进入克隆到的文件夹： 123cd xxx.github.ionpm installnpm install hexo-deployer-git --save 生成，部署： 12hexo ghexo d 然后就可以开始写你的新博客了 1hexo new newpage Tips: 不要忘了，每次写完最好都把源文件上传一下 123git add .git commit –m &quot;xxxx&quot;git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了 1git pull","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-10-24T10:48:45.000Z","updated":"2025-03-20T07:14:37.563Z","comments":true,"path":"2023/10/24/hello-world/","permalink":"http://example.com/2023/10/24/hello-world/","excerpt":"","text":"Hello World: 第一步，从这里开始​ 大家好，我是ZC，一名热衷于探索技术世界的程序员。今天，我怀着激动的心情写下我的第一篇博客。为什么选择“Hello World”作为开篇呢？这不仅仅是因为它几乎是每个程序员学习编程语言时的第一个程序，更因为它象征着我们与计算机世界的初次对话——简单、纯粹且充满无限可能。 编程之路的起点​ 回想起自己第一次在屏幕上敲出“Hello World”的那一刻，那种成就感至今仍然记忆犹新。那时的我对编程充满了好奇与敬畏，不知道接下来的学习之旅将会遇到什么样的挑战。随着时间的推移，我逐渐意识到，每一次代码的编写都是一次创造的过程，而每一个BUG的解决则像是一次小小的胜利。在这个过程中，我学会了如何用逻辑思考问题，如何将复杂的任务分解成可管理的部分，更重要的是，我学会了坚持不懈。 技术分享的意义​ 创建这个博客的目的，不仅仅是记录下我个人的技术成长历程，更是希望能够成为一个交流的平台。在这里，无论是初学者还是经验丰富的开发者，都可以找到有价值的信息，相互启发，共同进步。我相信，通过分享我们的知识、经验和见解，可以激发更多人的创造力，推动整个社区向前发展。 未来的展望​ 展望未来，我希望能够在这个博客上分享更多关于编程技巧、项目开发经验以及对最新技术趋势的思考。同时，我也期待着能够听到读者们的声音，无论是建议、批评还是鼓励，都是我不断前进的动力。让我们一起在这个数字世界中探索未知，创造价值。 ​ 最后，再次感谢您花时间阅读我的第一篇博客。如果您对编程有任何疑问或兴趣，欢迎随时留言交流。希望我们都能在技术的道路上越走越远，直到有一天，我们可以自豪地说：“Look what we’ve built!”","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/categories/ssl/"},{"name":"cmd","slug":"cmd","permalink":"http://example.com/categories/cmd/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"},{"name":"语雀","slug":"语雀","permalink":"http://example.com/tags/%E8%AF%AD%E9%9B%80/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}