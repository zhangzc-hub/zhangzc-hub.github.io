{"meta":{"title":"ZC程序员","subtitle":"解码技术与生活的奥秘","description":"这里是 ZC 的技术博客，一名热爱编程的程序员，分享技术心得和个人生活感悟。让我们一起在代码的海洋中遨游，感受技术与生活的美妙交响。","author":"ZZC","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-11-26T00:30:44.002Z","updated":"2024-11-26T00:30:44.002Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"技术与梦想的交汇点 —— 我的故事大家好，欢迎来到我的小天地！我是ZC，一名对科技充满热情的探索者。在这个日新月异的时代，我坚信技术不仅仅是工具，更是改变世界的力量。今天，我想与大家分享我的旅程，以及那些激励我前行的故事。 一、起点我的故事始于一个普通的小城市。从小我就对电子设备充满了好奇，经常拆解家里的收音机、遥控器等，试图了解它们是如何工作的。这份好奇心随着年龄的增长而愈发强烈，最终引领我走上了计算机科学的道路。 二、求学之路大学时期，我选择了计算机科学作为我的专业。在校园里，我不仅学到了编程的基础知识，更重要的是，我学会了如何思考问题、解决问题。参与各类项目比赛的经历让我意识到，团队合作与创新思维同样重要。这些宝贵的经验为我后来的职业生涯打下了坚实的基础。 三、职业发展毕业后，我加入了一家知名的互联网公司，担任软件工程师一职。在这里，我有幸参与到多个大型项目的开发中，见证了从概念设计到产品上线的全过程。这段经历极大地拓宽了我的视野，也加深了我对技术变革社会潜力的认识。 随着时间的推移，我逐渐意识到，仅仅作为一名开发者并不足以满足我对世界的渴望。我渴望将自己的想法与更多人分享，于是决定开设这个博客，希望能够成为一个连接技术与人文的桥梁。 四、创建博客创建这个博客的目的很简单：分享知识、激发灵感、促进交流。我希望通过撰写技术文章、行业观察以及个人感悟，不仅能够帮助读者解决实际问题，更能激发他们对未来的想象。我相信，每个人都有潜力成为改变世界的一份子。 五、展望未来未来，我将继续走在技术的前沿，不断学习新的知识和技术。同时，我也希望通过这个平台，与更多的志同道合者相遇，共同探讨技术如何更好地服务于人类社会。无论前方道路如何变化，我都将保持初心，勇敢前行。 感谢每一位访问者，因为有了你们的支持与陪伴，这段旅程才更加精彩。期待在未来的日子里，我们能够一起见证更多的奇迹发生。"},{"title":"所有标签","date":"2024-11-25T11:22:46.949Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-11-25T11:22:55.110Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2024-11-25T11:23:05.900Z","updated":"2024-11-25T02:47:34.388Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"若依框架中使用Velocity模块引擎改造代码生成功能","slug":"若依框架中使用Velocity模块引擎改造代码生成功能","date":"2025-09-04T06:10:15.000Z","updated":"2025-11-05T02:15:07.748Z","comments":true,"path":"2025/09/04/若依框架中使用Velocity模块引擎改造代码生成功能/","permalink":"http://example.com/2025/09/04/%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8Velocity%E6%A8%A1%E5%9D%97%E5%BC%95%E6%93%8E%E6%94%B9%E9%80%A0%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%8A%9F%E8%83%BD/","excerpt":"","text":"若依框架中使用Velocity模块引擎改造代码生成功能 支持mybatis-plus 支持Lombok 支持Swagger自动添加 支持LocalDateTime 在若依框架中，主要生成代码的模块是zzyl-generator模块 上述代码中，以vm为后缀的文件，其实是velocity模板引擎的对应的模板文件，如果想要改造代码生成的内容，我们必须要先学习velocity，而后再来看懂这些代码，才能支撑我们去改造这些模板文件，来生成我们想要的内容 1、Velocity模块引擎1.1、概述Velocity是一个基于Java的模板引擎，可以通过特定的语法获取在java对象的数据 , 填充到模板中，从而实现界面和java代码的分离 ! 常见的应用场景： Web应用程序 : 作为为应用程序的视图, 展示数据。 源代码生成 : Velocity可用于基于模板生成Java源代码。 自动电子邮件 : 网站注册 , 认证等的电子邮件模板。 网页静态化 : 基于velocity模板 , 生成静态网页。 1.2、快速入门需求：根据下面html模板，完成对数据的填充 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;velocity快速入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;心怀梦想，坚持不懈，成功即在前方。加油少年！&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 要求：加油少年，这几个字，需要使用动态填充进来 入门案例实现步骤 ①准备模板 把上面提供的html文档，拷贝一份到若依项目中的ruoyi-generator模块下的reources目录中 模板文件命名：index.html.vm 如下图 模板文件内容： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;velocity快速入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;心怀梦想，坚持不懈，成功即在前方。$&#123;message&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 注意：上述代码中的 加油少年 修改为了 ${message} 这是一个动态变量，方便动态填充数据 ②编写java代码实现数据填充，并生成文件 123456789101112131415161718192021222324252627282930313233343536import com.ruoyi.common.constant.Constants;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.Velocity;import java.io.FileWriter;import java.io.IOException;import java.util.Properties;public class VelocityDemoTest &#123; public static void main(String[] args) throws IOException &#123; Properties p = new Properties(); //velocity资源加载器，告诉模板引擎到类路径下寻找资源（比如模板） p.setProperty(&quot;resource.loader.file.class&quot;, &quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;); // 定义字符集 p.setProperty(Velocity.INPUT_ENCODING, Constants.UTF8); //初始化velocity引擎 Velocity.init(p); //创建velocity上下文对象 VelocityContext context = new VelocityContext(); //数据模型，这里的key需要跟模板中的变量对应上，不然填充不了数据 context.put(&quot;message&quot;, &quot;加油朋友！！！&quot;); //获取模板 Template template = Velocity.getTemplate(&quot;vms/index.html.vm&quot;, &quot;UTF-8&quot;); //输出 FileWriter fileWriter = new FileWriter(&quot;D:\\\\workspace\\\\index.html&quot;); //合并模板和数据模型 template.merge(context,fileWriter); //关闭流 fileWriter.close(); &#125;&#125; 最终的效果： 在指定的目录中生成index.html文件 打开之后的效果： 1.3、AI辅助解读Velocity语法大模型解读后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// Velocity模板开始，定义包名package $&#123;packageName&#125;.domain;// 循环导入所需的类库#foreach ($import in $importList)import $&#123;import&#125;;#end// 导入其他必要的类库import org.apache.commons.lang3.builder.ToStringBuilder;import org.apache.commons.lang3.builder.ToStringStyle;import com.zzyl.common.annotation.Excel;#if($table.crud || $table.sub)import com.zzyl.common.core.domain.BaseEntity;#elseif($table.tree)import com.zzyl.common.core.domain.TreeEntity;#end/** * $&#123;functionName&#125;对象 $&#123;tableName&#125; * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */#if($table.crud || $table.sub)#set($Entity=&quot;BaseEntity&quot;)#elseif($table.tree)#set($Entity=&quot;TreeEntity&quot;)#end// 定义Java类，继承自BaseEntity或TreeEntitypublic class $&#123;ClassName&#125; extends $&#123;Entity&#125;&#123; // 序列化版本ID private static final long serialVersionUID = 1L; // 循环定义类中的属性 #foreach ($column in $columns) #if(!$table.isSuperColumn($column.javaField)) // 添加属性的注释 /** $column.columnComment */ // 根据属性是否为列表类型，决定是否添加Excel注解 #if($column.list) #set($parentheseIndex=$column.columnComment.indexOf(&quot;（&quot;)) #if($parentheseIndex != -1) #set($comment=$column.columnComment.substring(0, $parentheseIndex)) #else #set($comment=$column.columnComment) #end #if($parentheseIndex != -1) // 如果属性名中有括号，则截取括号前的内容作为Excel注解的名字 @Excel(name = &quot;$&#123;comment&#125;&quot;, readConverterExp = &quot;$column.readConverterExp()&quot;) #else // 如果是日期类型，添加JSON格式化注解 #elseif($column.javaType == &#x27;Date&#x27;) @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) @Excel(name = &quot;$&#123;comment&#125;&quot;, width = 30, dateFormat = &quot;yyyy-MM-dd&quot;) #else // 其他情况直接添加Excel注解 @Excel(name = &quot;$&#123;comment&#125;&quot;) #end #end // 定义属性 private $column.javaType $column.javaField; #end #end // 如果是子表，添加子表的集合属性 #if($table.sub) /** $table.subTable.functionName信息 */ private List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List; #end // 生成getter和setter方法 #foreach ($column in $columns) #if(!$table.isSuperColumn($column.javaField)) #if($column.javaField.length() &gt; 2 &amp;&amp; $column.javaField.substring(1,2).matches(&quot;[A-Z]&quot;)) #set($AttrName=$column.javaField) #else #set($AttrName=$column.javaField.substring(0,1).toUpperCase() + $&#123;column.javaField.substring(1)&#125;) #end // setter方法 public void set$&#123;AttrName&#125;($column.javaType $column.javaField) &#123; this.$column.javaField = $column.javaField; &#125; // getter方法 public $column.javaType get$&#123;AttrName&#125;() &#123; return $column.javaField; &#125; #end #end // 如果是子表，生成子表集合的getter和setter方法 #if($table.sub) public List&lt;$&#123;subClassName&#125;&gt; get$&#123;subClassName&#125;List() &#123; return $&#123;subclassName&#125;List; &#125; public void set$&#123;subClassName&#125;List(List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List) &#123; this.$&#123;subclassName&#125;List = $&#123;subclassName&#125;List; &#125; #end // 重写toString方法 @Override public String toString() &#123; return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE) #foreach ($column in $columns) #if($column.javaField.length() &gt; 2 &amp;&amp; $column.javaField.substring(1,2).matches(&quot;[A-Z]&quot;)) #set($AttrName=$column.javaField) #else #set($AttrName=$column.javaField.substring(0,1).toUpperCase() + $&#123;column.javaField.substring(1)&#125;) #end .append(&quot;$&#123;column.javaField&#125;&quot;, get$&#123;AttrName&#125;()) #end #if($table.sub) .append(&quot;$&#123;subclassName&#125;List&quot;, get$&#123;subClassName&#125;List()) #end .toString(); &#125;&#125; Velocity语法解释 $&#123;variable&#125;: 表示插入变量值。 #foreach 和 #end: 循环结构，用于遍历列表。 #if 和 #end: 条件判断结构。 #set: 设置变量。 #elseif: 条件分支。 Java类结构说明 包声明: 定义类所在的包。 导入语句: 导入类所需要的类库。 类注释: 描述类的功能和作者信息。 类定义: 定义类并继承自BaseEntity或TreeEntity。 属性定义: 根据模板参数定义类的属性。 属性注释: 对属性进行描述。 Excel注解: 标记属性以方便导出Excel。 getter和setter方法: 自动生成属性的访问方法。 子表集合: 如果是子表，则定义子表集合。 重写toString方法: 提供类实例的字符串表示形式。 2、代码生成流程目前，我们已经基本熟悉了velocity的作用和一些语法，那接下来，我们就通过这些知识来去改造若依框架的代码生成部分，在改造之前，我们对于生成代码的核心部分来阅读一下 代码位置：com.zzyl.generator.service.GenTableServiceImpl.generatorCode() 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 生成代码 * @param tableName 表名 * @param zip 压缩输出流 */private void generatorCode(String tableName, ZipOutputStream zip)&#123; // 查询表信息 GenTable table = genTableMapper.selectGenTableByName(tableName); // 设置主子表信息 setSubTable(table); // 设置主键列信息 setPkColumn(table); // 初始化Velocity引擎 VelocityInitializer.initVelocity(); // 准备Velocity上下文 获取详细的该表的数据，并设置模板所需要的数据模型 VelocityContext context = VelocityUtils.prepareContext(table); // 获取模板列表 读取resources/vm目录中的定义的模板文件 List&lt;String&gt; templates = VelocityUtils.getTemplateList(table.getTplCategory(), table.getTplWebType()); for (String template : templates) &#123; // 渲染模板 StringWriter sw = new StringWriter(); Template tpl = Velocity.getTemplate(template, Constants.UTF8); // 合并模板和数据模型 tpl.merge(context, sw); try &#123; // 将渲染结果添加到zip文件 zip.putNextEntry(new ZipEntry(VelocityUtils.getFileName(template, table))); IOUtils.write(sw.toString(), zip, Constants.UTF8); IOUtils.closeQuietly(sw); zip.flush(); zip.closeEntry(); &#125; catch (IOException e) &#123; // 记录日志 log.error(&quot;渲染模板失败，表名：&quot; + table.getTableName(), e); &#125; &#125;&#125; 3、Lombok集成3.1、依赖导入12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt;&lt;/dependency&gt; 3.2、修改模板我们主要修改的模板为 domain.java.vm，让它支持lombok 修改模板如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package $&#123;packageName&#125;.domain;#foreach ($import in $importList)import $&#123;import&#125;;#endimport org.apache.commons.lang3.builder.ToStringBuilder; ## 用不到，可删import org.apache.commons.lang3.builder.ToStringStyle; ## 用不到，可删import com.zzyl.common.annotation.Excel;#if($table.crud || $table.sub)import com.zzyl.common.core.domain.BaseEntity;#elseif($table.tree)import com.zzyl.common.core.domain.TreeEntity;#endimport lombok.Data; ## 导入lombok的依赖/** * $&#123;functionName&#125;对象 $&#123;tableName&#125; * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */#if($table.crud || $table.sub)#set($Entity=&quot;BaseEntity&quot;)#elseif($table.tree)#set($Entity=&quot;TreeEntity&quot;)#end@Data ## 添加lombok的注解public class $&#123;ClassName&#125; extends $&#123;Entity&#125;&#123; private static final long serialVersionUID = 1L;#foreach ($column in $columns)#if(!$table.isSuperColumn($column.javaField)) /** $column.columnComment */#if($column.list)#set($parentheseIndex=$column.columnComment.indexOf(&quot;（&quot;))#if($parentheseIndex != -1)#set($comment=$column.columnComment.substring(0, $parentheseIndex))#else#set($comment=$column.columnComment)#end#if($parentheseIndex != -1) @Excel(name = &quot;$&#123;comment&#125;&quot;, readConverterExp = &quot;$column.readConverterExp()&quot;)#elseif($column.javaType == &#x27;Date&#x27;) @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) @Excel(name = &quot;$&#123;comment&#125;&quot;, width = 30, dateFormat = &quot;yyyy-MM-dd&quot;)#else @Excel(name = &quot;$&#123;comment&#125;&quot;)#end#end private $column.javaType $column.javaField;#end#end#if($table.sub) /** $table.subTable.functionName信息 */ private List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List;#end## 以下是生成属性的get/set方法 start.... 删除这部分内容#foreach ($column in $columns)#if(!$table.isSuperColumn($column.javaField))#if($column.javaField.length() &gt; 2 &amp;&amp; $column.javaField.substring(1,2).matches(&quot;[A-Z]&quot;))#set($AttrName=$column.javaField)#else#set($AttrName=$column.javaField.substring(0,1).toUpperCase() + $&#123;column.javaField.substring(1)&#125;)#end public void set$&#123;AttrName&#125;($column.javaType $column.javaField) &#123; this.$column.javaField = $column.javaField; &#125; public $column.javaType get$&#123;AttrName&#125;() &#123; return $column.javaField; &#125;#end#end## 以下是生成属性的get/set方法 end.... 删除这部分内容## 如果是主子表，生成子表相关的get/set方法，start.... 删除这部分内容#if($table.sub) public List&lt;$&#123;subClassName&#125;&gt; get$&#123;subClassName&#125;List() &#123; return $&#123;subclassName&#125;List; &#125; public void set$&#123;subClassName&#125;List(List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List) &#123; this.$&#123;subclassName&#125;List = $&#123;subclassName&#125;List; &#125;#end## 如果是主子表，生成子表相关的get/set方法，end.... 删除这部分内容##以下代码生成 toString方法， start.... 删除这部分内容 @Override public String toString() &#123; return new ToStringBuilder(this,ToStringStyle.MULTI_LINE_STYLE)#foreach ($column in $columns)#if($column.javaField.length() &gt; 2 &amp;&amp; $column.javaField.substring(1,2).matches(&quot;[A-Z]&quot;))#set($AttrName=$column.javaField)#else#set($AttrName=$column.javaField.substring(0,1).toUpperCase() + $&#123;column.javaField.substring(1)&#125;)#end .append(&quot;$&#123;column.javaField&#125;&quot;, get$&#123;AttrName&#125;())#end#if($table.sub) .append(&quot;$&#123;subclassName&#125;List&quot;, get$&#123;subClassName&#125;List())#end .toString(); &#125;##以下代码生成 toString方法， end.... 删除这部分内容&#125; 3.3、生成后的效果修改完成之后，重启项目，找到代码生成的功能，通过代码预览可以查看实体类的代码： 正常添加了关于lombok的注解 删除了setter、 getter 、toString 等方法 测试 可以把生成后的代码，拷贝到项目中，如果护理项目能够正常访问和操作，就算修改成功了，后期再次生成的代码，全部都支持lombok 4、Mybatis-Plus集成我们改造主要参考的是官方推荐的项目：https://gitee.com/tellsea/ruoyi-vue-plus（目前已集成mybatis-plus） 4.1、添加依赖在父工程中的pom文件中添加mybatis-plus的依赖，如下： 1234567891011121314151617181920&lt;properties&gt; &lt;mybatis-plus-spring-boot.version&gt;3.5.2&lt;/mybatis-plus-spring-boot.version&gt;&lt;/properties&gt;&lt;!-- 依赖声明 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- mybatis-plus 增强CRUD --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus-spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-annotation&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-plus-spring-boot.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在zzyl-common模块中新增mybatis-plus的依赖 12345678&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-annotation&lt;/artifactId&gt;&lt;/dependency&gt; 4.2、核心配置appliation.yml文件中新增MyBatisPlus配置，同时删除Mybatis相关的配置 123456789101112# MyBatisPlus配置mybatis-plus: # 搜索指定包别名 typeAliasesPackage: com.zzyl.**.domain # 配置mapper的扫描，找到所有的mapper.xml映射文件 mapperLocations: classpath*:mapper/**/*Mapper.xml # 全局配置 global-config: db-config: id-type: auto #id生成策略为自增 configuration: map-underscore-to-camel-case: true #字段与属性，自动转换为驼峰命名 新增核心配置类，删除MyBatisConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.zzyl.framework.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.BlockAttackInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * Mybatis Plus 配置 * * @author ruoyi */@EnableTransactionManagement(proxyTargetClass = true)@Configurationpublic class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // 分页插件 interceptor.addInnerInterceptor(paginationInnerInterceptor()); // 乐观锁插件 interceptor.addInnerInterceptor(optimisticLockerInnerInterceptor()); // 阻断插件 interceptor.addInnerInterceptor(blockAttackInnerInterceptor()); return interceptor; &#125; /** * 分页插件，自动识别数据库类型 https://baomidou.com/guide/interceptor-pagination.html */ public PaginationInnerInterceptor paginationInnerInterceptor() &#123; PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor(); // 设置数据库类型为mysql paginationInnerInterceptor.setDbType(DbType.MYSQL); // 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInnerInterceptor.setMaxLimit(-1L); return paginationInnerInterceptor; &#125; /** * 乐观锁插件 https://baomidou.com/guide/interceptor-optimistic-locker.html */ public OptimisticLockerInnerInterceptor optimisticLockerInnerInterceptor() &#123; return new OptimisticLockerInnerInterceptor(); &#125; /** * 如果是对全表的删除或更新操作，就会终止该操作 https://baomidou.com/guide/interceptor-block-attack.html */ public BlockAttackInnerInterceptor blockAttackInnerInterceptor() &#123; return new BlockAttackInnerInterceptor(); &#125;&#125; 4.3、代码生成模板在目前的模板文件中，我们需要修改的模板共有3个，分别是： mapper.java.vm 继承BaseMapper service.java.vm 继承IService serviceImpl.java.vm 继承ServiceImpl&lt;XxxMapper,T&gt; 常见方法的使用（单表的增删改查） domain.java.vm 无需修改，类名与表名一致，会自动映射，主键已经在yaml文件中配置 controller.java.vm 无需修改，保留原有的接口方法和命名 mapper.java.vm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package $&#123;packageName&#125;.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import org.apache.ibatis.annotations.Mapper;import java.util.List;import $&#123;packageName&#125;.domain.$&#123;ClassName&#125;;#if($table.sub)import $&#123;packageName&#125;.domain.$&#123;subClassName&#125;;#end/** * $&#123;functionName&#125;Mapper接口 * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */@Mapperpublic interface $&#123;ClassName&#125;Mapper extends BaseMapper&lt;$&#123;ClassName&#125;&gt;&#123; /** * 查询$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return $&#123;functionName&#125; */ public $&#123;ClassName&#125; select$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;); /** * 查询$&#123;functionName&#125;列表 * * @param $&#123;className&#125; $&#123;functionName&#125; * @return $&#123;functionName&#125;集合 */ public List&lt;$&#123;ClassName&#125;&gt; select$&#123;ClassName&#125;List($&#123;ClassName&#125; $&#123;className&#125;); /** * 新增$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */ public int insert$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;); /** * 修改$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */ public int update$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;); /** * 删除$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return 结果 */ public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;); /** * 批量删除$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125;s 需要删除的数据主键集合 * @return 结果 */ public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;s($&#123;pkColumn.javaType&#125;[] $&#123;pkColumn.javaField&#125;s);#if($table.sub) /** * 批量删除$&#123;subTable.functionName&#125; * * @param $&#123;pkColumn.javaField&#125;s 需要删除的数据主键集合 * @return 结果 */ public int delete$&#123;subClassName&#125;By$&#123;subTableFkClassName&#125;s($&#123;pkColumn.javaType&#125;[] $&#123;pkColumn.javaField&#125;s); /** * 批量新增$&#123;subTable.functionName&#125; * * @param $&#123;subclassName&#125;List $&#123;subTable.functionName&#125;列表 * @return 结果 */ public int batch$&#123;subClassName&#125;(List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List); /** * 通过$&#123;functionName&#125;主键删除$&#123;subTable.functionName&#125;信息 * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;ID * @return 结果 */ public int delete$&#123;subClassName&#125;By$&#123;subTableFkClassName&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;);#end&#125; service.java.vm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package $&#123;packageName&#125;.service;import com.baomidou.mybatisplus.extension.service.IService;import java.util.List;import $&#123;packageName&#125;.domain.$&#123;ClassName&#125;;/** * $&#123;functionName&#125;Service接口 * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */public interface I$&#123;ClassName&#125;Service extends IService&lt;$&#123;ClassName&#125;&gt;&#123; /** * 查询$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return $&#123;functionName&#125; */ public $&#123;ClassName&#125; select$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;); /** * 查询$&#123;functionName&#125;列表 * * @param $&#123;className&#125; $&#123;functionName&#125; * @return $&#123;functionName&#125;集合 */ public List&lt;$&#123;ClassName&#125;&gt; select$&#123;ClassName&#125;List($&#123;ClassName&#125; $&#123;className&#125;); /** * 新增$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */ public int insert$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;); /** * 修改$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */ public int update$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;); /** * 批量删除$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125;s 需要删除的$&#123;functionName&#125;主键集合 * @return 结果 */ public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;s($&#123;pkColumn.javaType&#125;[] $&#123;pkColumn.javaField&#125;s); /** * 删除$&#123;functionName&#125;信息 * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return 结果 */ public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;);&#125; serviceImpl.java.vm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178package $&#123;packageName&#125;.service.impl;import java.util.List;#foreach ($column in $columns)#if($column.javaField == &#x27;createTime&#x27; || $column.javaField == &#x27;updateTime&#x27;)import com.zzyl.common.utils.DateUtils;#break#end#endimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;#if($table.sub)import java.util.ArrayList;import com.zzyl.common.utils.StringUtils;import org.springframework.transaction.annotation.Transactional;import $&#123;packageName&#125;.domain.$&#123;subClassName&#125;;#endimport $&#123;packageName&#125;.mapper.$&#123;ClassName&#125;Mapper;import $&#123;packageName&#125;.domain.$&#123;ClassName&#125;;import $&#123;packageName&#125;.service.I$&#123;ClassName&#125;Service;import $&#123;packageName&#125;.mapper.$&#123;ClassName&#125;Mapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import java.util.Arrays;/** * $&#123;functionName&#125;Service业务层处理 * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */@Servicepublic class $&#123;ClassName&#125;ServiceImpl extends ServiceImpl&lt;$&#123;ClassName&#125;Mapper, $&#123;ClassName&#125;&gt; implements I$&#123;ClassName&#125;Service&#123; @Autowired private $&#123;ClassName&#125;Mapper $&#123;className&#125;Mapper; /** * 查询$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return $&#123;functionName&#125; */ @Override public $&#123;ClassName&#125; select$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;) &#123; ##return $&#123;className&#125;Mapper.select$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaField&#125;); return getById($&#123;pkColumn.javaField&#125;); &#125; /** * 查询$&#123;functionName&#125;列表 * * @param $&#123;className&#125; $&#123;functionName&#125; * @return $&#123;functionName&#125; */ @Override public List&lt;$&#123;ClassName&#125;&gt; select$&#123;ClassName&#125;List($&#123;ClassName&#125; $&#123;className&#125;) &#123; return $&#123;className&#125;Mapper.select$&#123;ClassName&#125;List($&#123;className&#125;); &#125; /** * 新增$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */#if($table.sub) @Transactional#end @Override public int insert$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;) &#123;#foreach ($column in $columns) 删除这些 新增的时候，给创建时间赋值#if($column.javaField == &#x27;createTime&#x27;) $&#123;className&#125;.setCreateTime(DateUtils.getNowDate());#end#end#if($table.sub) int rows = $&#123;className&#125;Mapper.insert$&#123;ClassName&#125;($&#123;className&#125;); insert$&#123;subClassName&#125;($&#123;className&#125;); return rows;#else ##return $&#123;className&#125;Mapper.insert$&#123;ClassName&#125;($&#123;className&#125;); return save($&#123;className&#125;) == true? 1 : 0;#end &#125; /** * 修改$&#123;functionName&#125; * * @param $&#123;className&#125; $&#123;functionName&#125; * @return 结果 */#if($table.sub) @Transactional#end @Override public int update$&#123;ClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;) &#123;#foreach ($column in $columns) 删除这些，修改的时候给修改时间赋值#if($column.javaField == &#x27;updateTime&#x27;) $&#123;className&#125;.setUpdateTime(DateUtils.getNowDate());#end#end#if($table.sub) $&#123;className&#125;Mapper.delete$&#123;subClassName&#125;By$&#123;subTableFkClassName&#125;($&#123;className&#125;.get$&#123;pkColumn.capJavaField&#125;()); insert$&#123;subClassName&#125;($&#123;className&#125;);#end## return $&#123;className&#125;Mapper.update$&#123;ClassName&#125;($&#123;className&#125;); return updateById($&#123;className&#125;) == true ? 1 : 0; &#125; /** * 批量删除$&#123;functionName&#125; * * @param $&#123;pkColumn.javaField&#125;s 需要删除的$&#123;functionName&#125;主键 * @return 结果 */#if($table.sub) @Transactional#end @Override public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;s($&#123;pkColumn.javaType&#125;[] $&#123;pkColumn.javaField&#125;s) &#123;#if($table.sub) $&#123;className&#125;Mapper.delete$&#123;subClassName&#125;By$&#123;subTableFkClassName&#125;s($&#123;pkColumn.javaField&#125;s);#end## return $&#123;className&#125;Mapper.delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;s($&#123;pkColumn.javaField&#125;s); return removeByIds(Arrays.asList($&#123;pkColumn.javaField&#125;s)) == true ? 1 : 0; &#125; /** * 删除$&#123;functionName&#125;信息 * * @param $&#123;pkColumn.javaField&#125; $&#123;functionName&#125;主键 * @return 结果 */#if($table.sub) @Transactional#end @Override public int delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;) &#123;#if($table.sub) $&#123;className&#125;Mapper.delete$&#123;subClassName&#125;By$&#123;subTableFkClassName&#125;($&#123;pkColumn.javaField&#125;);#end## return $&#123;className&#125;Mapper.delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaField&#125;); return removeById($&#123;pkColumn.javaField&#125;) == true ? 1 : 0; &#125;#if($table.sub) /** * 新增$&#123;subTable.functionName&#125;信息 * * @param $&#123;className&#125; $&#123;functionName&#125;对象 */ public void insert$&#123;subClassName&#125;($&#123;ClassName&#125; $&#123;className&#125;) &#123; List&lt;$&#123;subClassName&#125;&gt; $&#123;subclassName&#125;List = $&#123;className&#125;.get$&#123;subClassName&#125;List(); $&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125; = $&#123;className&#125;.get$&#123;pkColumn.capJavaField&#125;(); if (StringUtils.isNotNull($&#123;subclassName&#125;List)) &#123; List&lt;$&#123;subClassName&#125;&gt; list = new ArrayList&lt;$&#123;subClassName&#125;&gt;(); for ($&#123;subClassName&#125; $&#123;subclassName&#125; : $&#123;subclassName&#125;List) &#123; $&#123;subclassName&#125;.set$&#123;subTableFkClassName&#125;($&#123;pkColumn.javaField&#125;); list.add($&#123;subclassName&#125;); &#125; if (list.size() &gt; 0) &#123; $&#123;className&#125;Mapper.batch$&#123;subClassName&#125;(list); &#125; &#125; &#125;#end&#125; 其他必要修改 集成MP之后，项目中的BaseEntity类中的字段有些会受影响，需要添加如下注解 由于这几个字段，并不会跟数据库中的表字段进行映射，必须要添加@TableField(exist &#x3D; false)表示，表示该字段不存在于数据库表中 1234567891011121314151617181920/** * Entity基类 * * @author ruoyi */public class BaseEntity implements Serializable&#123; private static final long serialVersionUID = 1L; /** 搜索值 */ @JsonIgnore @TableField(exist = false) private String searchValue; /** 请求参数 */ @JsonInclude(JsonInclude.Include.NON_EMPTY) @TableField(exist = false) private Map&lt;String, Object&gt; params;&#125; 4.4、字段自动填充MyBatis-Plus 提供的字段自动填充功能是一种非常实用的特性，它能够在插入或更新数据库记录时自动填充一些公共字段，如创建时间（createTime）、更新时间（updateTime）、创建人（createBy）、更新人（updateBy）等。这一功能极大地简化了开发过程，减少了重复的代码编写，提高了开发效率。 官网链接：https://mybatis.plus/guide/auto-fill-metainfo.html（可能打不开，官网本身的问题） 在MybatisPlus中通过两步可以实现这个功能： 1、在实体类中，使用@TableField注解，来标明哪些字段是需要自动填充的，并且需要指定填充策略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.zzyl.common.core.domain;import java.io.Serializable;import java.util.Date;import java.util.HashMap;import java.util.Map;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.annotation.JsonIgnore;import com.fasterxml.jackson.annotation.JsonInclude;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * Entity基类 * * @author ruoyi */@ApiModel(&quot;Entity基类&quot;)public class BaseEntity implements Serializable&#123; private static final long serialVersionUID = 1L; /** 搜索值 */ @JsonIgnore @TableField(exist = false) private String searchValue; /** 创建者 */ @ApiModelProperty(value = &quot;创建者&quot;) @TableField(fill = FieldFill.INSERT) private String createBy; /** 创建时间 */ @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(value = &quot;创建时间&quot;) @TableField(fill = FieldFill.INSERT) private Date createTime; /** 更新者 */ @ApiModelProperty(value = &quot;更新者&quot;) @TableField(fill = FieldFill.UPDATE) private String updateBy; /** 更新时间 */ @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) @ApiModelProperty(value = &quot;更新时间&quot;) @TableField(fill = FieldFill.UPDATE) private Date updateTime; /** 备注 */ @ApiModelProperty(value = &quot;备注&quot;) private String remark; /** 请求参数 */ @JsonInclude(JsonInclude.Include.NON_EMPTY) @ApiModelProperty(value = &quot;请求参数&quot;) @TableField(exist = false) private Map&lt;String, Object&gt; params; &#125; 2、在zzyl-framework模块中新增MyMetaObjectHandler 来处理自动自动填充 详细的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.zzyl.framework.interceptor;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import com.zzyl.common.core.domain.model.LoginUser;import com.zzyl.common.utils.SecurityUtils;import org.apache.commons.lang3.ObjectUtils;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, &quot;createTime&quot;, Date.class, new Date()); this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, loadUserId()+&quot;&quot;); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject, &quot;updateTime&quot;, Date.class, new Date()); this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, loadUserId()+&quot;&quot;); &#125; /** * 获取当前登录人的ID * @return */ public static Long loadUserId()&#123; //获取当前登录人的id LoginUser loginUser = SecurityUtils.getLoginUser(); if(ObjectUtils.isNotEmpty(loginUser))&#123; return loginUser.getUserId(); &#125; return 1L; &#125;&#125; 5、Swagger集成在我们定义的所有controller中，为了更好的体现接口文档，我们都需要添加swagger注解才可以。这些注解我们也可以通过代码的模板来生成，节省我们的开发工作 我们主要的工作就是来修改controller.java.vm文件即可，具体的修改的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package $&#123;packageName&#125;.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import java.util.List;import javax.servlet.http.HttpServletResponse;import org.springframework.security.access.prepost.PreAuthorize;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.zzyl.common.annotation.Log;import com.zzyl.common.core.controller.BaseController;import com.zzyl.common.core.domain.AjaxResult;import com.zzyl.common.enums.BusinessType;import $&#123;packageName&#125;.domain.$&#123;ClassName&#125;;import $&#123;packageName&#125;.service.I$&#123;ClassName&#125;Service;import com.zzyl.common.utils.poi.ExcelUtil;#if($table.crud || $table.sub)import com.zzyl.common.core.page.TableDataInfo;#elseif($table.tree)#end/** * $&#123;functionName&#125;Controller * * @author $&#123;author&#125; * @date $&#123;datetime&#125; */@RestController@RequestMapping(&quot;/$&#123;moduleName&#125;/$&#123;businessName&#125;&quot;)@Api(tags = &quot;$&#123;functionName&#125;相关接口&quot;)public class $&#123;ClassName&#125;Controller extends BaseController&#123; @Autowired private I$&#123;ClassName&#125;Service $&#123;className&#125;Service; /** * 查询$&#123;functionName&#125;列表 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:list&#x27;)&quot;) @GetMapping(&quot;/list&quot;) @ApiOperation(&quot;查询$&#123;functionName&#125;列表&quot;)#if($table.crud || $table.sub) public TableDataInfo list($&#123;ClassName&#125; $&#123;className&#125;) &#123; startPage(); List&lt;$&#123;ClassName&#125;&gt; list = $&#123;className&#125;Service.select$&#123;ClassName&#125;List($&#123;className&#125;); return getDataTable(list); &#125;#elseif($table.tree) public AjaxResult list($&#123;ClassName&#125; $&#123;className&#125;) &#123; List&lt;$&#123;ClassName&#125;&gt; list = $&#123;className&#125;Service.select$&#123;ClassName&#125;List($&#123;className&#125;); return success(list); &#125;#end /** * 导出$&#123;functionName&#125;列表 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:export&#x27;)&quot;) @Log(title = &quot;$&#123;functionName&#125;&quot;, businessType = BusinessType.EXPORT) @PostMapping(&quot;/export&quot;) @ApiOperation(&quot;导出$&#123;functionName&#125;列表&quot;) public void export(HttpServletResponse response, $&#123;ClassName&#125; $&#123;className&#125;) &#123; List&lt;$&#123;ClassName&#125;&gt; list = $&#123;className&#125;Service.select$&#123;ClassName&#125;List($&#123;className&#125;); ExcelUtil&lt;$&#123;ClassName&#125;&gt; util = new ExcelUtil&lt;$&#123;ClassName&#125;&gt;($&#123;ClassName&#125;.class); util.exportExcel(response, list, &quot;$&#123;functionName&#125;数据&quot;); &#125; /** * 获取$&#123;functionName&#125;详细信息 */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:query&#x27;)&quot;) @GetMapping(value = &quot;/&#123;$&#123;pkColumn.javaField&#125;&#125;&quot;) @ApiOperation(&quot;获取$&#123;functionName&#125;详细信息&quot;) public AjaxResult getInfo(@ApiParam(value = &quot;$&#123;functionName&#125;ID&quot;, required = true) @PathVariable(&quot;$&#123;pkColumn.javaField&#125;&quot;) $&#123;pkColumn.javaType&#125; $&#123;pkColumn.javaField&#125;) &#123; return success($&#123;className&#125;Service.select$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;($&#123;pkColumn.javaField&#125;)); &#125; /** * 新增$&#123;functionName&#125; */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:add&#x27;)&quot;) @Log(title = &quot;$&#123;functionName&#125;&quot;, businessType = BusinessType.INSERT) @PostMapping @ApiOperation(&quot;新增$&#123;functionName&#125;&quot;) public AjaxResult add(@ApiParam(value = &quot;$&#123;functionName&#125;实体&quot;, required = true) @RequestBody $&#123;ClassName&#125; $&#123;className&#125;) &#123; return toAjax($&#123;className&#125;Service.insert$&#123;ClassName&#125;($&#123;className&#125;)); &#125; /** * 修改$&#123;functionName&#125; */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:edit&#x27;)&quot;) @Log(title = &quot;$&#123;functionName&#125;&quot;, businessType = BusinessType.UPDATE) @PutMapping @ApiOperation(&quot;修改$&#123;functionName&#125;&quot;) public AjaxResult edit(@ApiParam(value = &quot;$&#123;functionName&#125;实体&quot;, required = true) @RequestBody $&#123;ClassName&#125; $&#123;className&#125;) &#123; return toAjax($&#123;className&#125;Service.update$&#123;ClassName&#125;($&#123;className&#125;)); &#125; /** * 删除$&#123;functionName&#125; */ @PreAuthorize(&quot;@ss.hasPermi(&#x27;$&#123;permissionPrefix&#125;:remove&#x27;)&quot;) @Log(title = &quot;$&#123;functionName&#125;&quot;, businessType = BusinessType.DELETE) @DeleteMapping(&quot;/&#123;$&#123;pkColumn.javaField&#125;s&#125;&quot;) @ApiOperation(&quot;删除$&#123;functionName&#125;&quot;) public AjaxResult remove(@PathVariable $&#123;pkColumn.javaType&#125;[] $&#123;pkColumn.javaField&#125;s) &#123; return toAjax($&#123;className&#125;Service.delete$&#123;ClassName&#125;By$&#123;pkColumn.capJavaField&#125;s($&#123;pkColumn.javaField&#125;s)); &#125;&#125; 重启服务之后，我们可以预览生成后的效果： 6、由Date类型改为LocalDateTime若依目前提供的代码中，如果遇到日期类型则使用的是Date，由于目前使用比较流行的是LocalDateTime类型，我们也可以把它改为该类型进行使用 知识扩展 Date类型与LocalDateTime的区别？ 不可变性与线程安全性 Date一旦创建Date对象，可以通过setTime(long time)进行修改，多线程下存在线程安全问题 LocalDateTime是不可变的，线程安全 时间精度 Date可以表示到毫秒的时间值 LocalDateTime可以表示到纳秒的时间值 易用性：LocalDateTime的API设计的更现代化，易于使用 在目前代码生成中，其中字段详细这一栏中的Java类型并不支持LocalDateTime类型，所以我们需要在前端也要修改其内容，让它支持LocalDateTime 打开前端项目，找到src&#x2F;views&#x2F;tool&#x2F;gen&#x2F;editTable.vue文件，在这个文件添加中以上一行代码，如下： 当前端选择了LocalDateTime类型之后，在后端的代码生成中，需要导入对应的包才可以，后端的代码也需要修改 我们打开VelocityUtils类，这里面有处理导入包的逻辑，找到getImportList方法，在其中添加对应的包导入 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 根据列类型获取导入包 * * @param genTable 业务表对象 * @return 返回需要导入的包列表 */public static HashSet&lt;String&gt; getImportList(GenTable genTable)&#123; List&lt;GenTableColumn&gt; columns = genTable.getColumns(); GenTable subGenTable = genTable.getSubTable(); HashSet&lt;String&gt; importList = new HashSet&lt;String&gt;(); if (StringUtils.isNotNull(subGenTable)) &#123; importList.add(&quot;java.util.List&quot;); &#125; for (GenTableColumn column : columns) &#123; if (!column.isSuperColumn() &amp;&amp; GenConstants.TYPE_DATE.equals(column.getJavaType())) &#123; importList.add(&quot;java.util.Date&quot;); importList.add(&quot;com.fasterxml.jackson.annotation.JsonFormat&quot;); &#125; else if (!column.isSuperColumn() &amp;&amp; GenConstants.TYPE_BIGDECIMAL.equals(column.getJavaType())) &#123; importList.add(&quot;java.math.BigDecimal&quot;); &#125; //加入下面这些功能 // 如果字段类型在前端选择的是LocalDateTime，则导入对应的包 if (!column.isSuperColumn() &amp;&amp; &quot;LocalDateTime&quot;.equals(column.getJavaType())) &#123; importList.add(&quot;java.time.LocalDateTime&quot;); //导入这个是为了格式化日期 importList.add(&quot;com.fasterxml.jackson.annotation.JsonFormat&quot;); &#125; &#125; return importList;&#125; 修改模块文件domain.java.vm文件，修改的内容如下：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"若依","slug":"若依","permalink":"http://example.com/tags/%E8%8B%A5%E4%BE%9D/"}]},{"title":"Redis集群搭建","slug":"Redis集群搭建","date":"2025-03-20T06:36:00.000Z","updated":"2025-03-20T11:59:22.809Z","comments":true,"path":"2025/03/20/Redis集群搭建/","permalink":"http://example.com/2025/03/20/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/","excerpt":"","text":"Redis集群搭建1、Redis主从集群1.1、集群结构搭建的主从集群结构如图： 共包含三个节点，一个主节点，两个从节点。 在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 slave 192.168.150.101 7003 slave 1.2、准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 1）创建目录 创建三个文件夹，名字分别叫7001、7002、7003： 1234# 进入/tmp目录cd /tmp# 创建目录mkdir 7001 7002 7003 2）恢复原始配置 修改redis-6.2.4&#x2F;redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。 12345678# 开启RDB# save &quot;&quot;save 3600 1save 300 100save 60 10000# 关闭AOFappendonly no 3）拷贝配置文件到每个实例目录 然后将redis-6.2.4&#x2F;redis.conf文件拷贝到三个目录中（在&#x2F;tmp目录执行下列命令）： 123456# 方式一：逐个拷贝cp redis-6.2.4/redis.conf 7001cp redis-6.2.4/redis.conf 7002cp redis-6.2.4/redis.conf 7003# 方式二：管道组合命令，一键拷贝echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf 4）修改每个实例的端口、工作目录 修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在&#x2F;tmp目录执行下列命令）： 123sed -i -e &#x27;s/6379/7001/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7001\\//g&#x27; 7001/redis.confsed -i -e &#x27;s/6379/7002/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7002\\//g&#x27; 7002/redis.confsed -i -e &#x27;s/6379/7003/g&#x27; -e &#x27;s/dir .\\//dir \\/tmp\\/7003\\//g&#x27; 7003/redis.conf 5）修改每个实例的声明IP 虚拟机本身有多个IP，为了避免将来混乱，需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下： 12# redis实例的声明 IPreplica-announce-ip 192.168.150.101 每个目录都要改，我们一键完成修改（在&#x2F;tmp目录执行下列命令）： 1234567# 逐一执行sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7001/redis.confsed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7002/redis.confsed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; 7003/redis.conf# 或者一键修改printf &#x27;%s\\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i &#x27;1a replica-announce-ip 192.168.150.101&#x27; &#123;&#125;/redis.conf 1.3、启动12345678910# 第1个redis-server 7001/redis.conf# 第2个redis-server 7002/redis.conf# 第3个redis-server 7003/redis.conf或./redis-6.2.4/src/redis-server ./7001/redis.conf./redis-6.2.4/src/redis-server ./7002/redis.conf./redis-6.2.4/src/redis-server ./7003/redis.conf 启动后： 12# 如果要一键停止，可以运行下面命令：printf &#x27;%s\\n&#x27; 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 1.4、开启主从关系现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。 有临时和永久两种模式： 修改配置文件（永久生效） slaveof 使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）： 1slaveof &lt;masterip&gt; &lt;masterport&gt; 注意：在5.0以后新增命令replicaof，与salveof效果一致。 这里我们为了演示方便，使用方式二。 通过redis-cli命令连接7002，执行下面命令： 1234# 连接 7002redis-cli -p 7002# 执行slaveofslaveof 124.183.178.142 7001 通过redis-cli命令连接7003，执行下面命令： 1234# 连接 7003redis-cli -p 7003# 执行slaveofslaveof 192.168.150.101 7001 然后连接 7001节点，查看集群状态： 1234# 连接 7001redis-cli -p 7001# 查看状态info replication 结果： 1.5、测试执行下列操作以测试： 利用redis-cli连接7001，执行 1set num 123 利用redis-cli连接7002，执行 12get num，再执行set num 666 利用redis-cli连接7003，执行 12get num，再执行set num 888 可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。 2、搭建哨兵集群2.1、集群结构这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图： 三个sentinel实例信息如下： 节点 IP PORT s1 192.168.150.101 27001 s2 192.168.150.101 27002 s3 192.168.150.101 27003 3.2.准备实例和配置要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。 我们创建三个文件夹，名字分别叫s1、s2、s3： 1234# 进入/tmp目录cd /tmp# 创建目录mkdir s1 s2 s3 然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容： 123456port 27001sentinel announce-ip 192.168.150.101sentinel monitor mymaster 192.168.150.101 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir &quot;/tmp/s1&quot; 解读： port 27001 ：是当前sentinel实例的端口 sentinel monitor mymaster 192.168.150.101 7001 2 ：指定主节点信息 mymaster ：主节点名称，自定义，任意写 192.168.150.101 7001 ：主节点的ip和端口 2 ：选举master时的quorum值 然后将s1&#x2F;sentinel.conf文件拷贝到s2、s3两个目录中（在&#x2F;tmp目录执行下列命令）： 12345# 方式一：逐个拷贝cp s1/sentinel.conf s2cp s1/sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf 修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003： 12sed -i -e &#x27;s/27001/27002/g&#x27; -e &#x27;s/s1/s2/g&#x27; s2/sentinel.confsed -i -e &#x27;s/27001/27003/g&#x27; -e &#x27;s/s1/s3/g&#x27; s3/sentinel.conf 2.3、启动为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令： 123456789# 第1个redis-sentinel s1/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s1/sentinel.conf# 第2个redis-sentinel s2/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s2/sentinel.conf# 第3个redis-sentinel s3/sentinel.conf./redis-6.2.4/src/redis-sentinel ./s3/sentinel.conf 启动后： 2.3、测试尝试让master节点7001宕机，查看sentinel日志： 查看7003的日志： 查看7002的日志： 3、搭建分片集群3.1、集群结构分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下： 这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下： IP PORT 角色 192.168.150.101 7001 master 192.168.150.101 7002 master 192.168.150.101 7003 master 192.168.150.101 8001 slave 192.168.150.101 8002 slave 192.168.150.101 8003 slave 3.2、准备实例和配置删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录： 123456# 进入/tmp目录cd /tmp# 删除旧的，避免配置干扰rm -rf 7001 7002 7003# 创建目录mkdir 7001 7002 7003 8001 8002 8003 在&#x2F;tmp下准备一个新的redis.conf文件，内容如下： 123456789101112131415161718192021port 6379# 开启集群功能cluster-enabled yes# 集群的配置文件名称，不需要我们创建，由redis自己维护cluster-config-file /tmp/6379/nodes.conf# 节点心跳失败的超时时间cluster-node-timeout 5000# 持久化文件存放目录dir /tmp/6379# 绑定地址bind 0.0.0.0# 让redis后台运行,守护进程daemonize yes# 注册的实例ipreplica-announce-ip 192.168.150.101# 保护模式protected-mode no# 数据库数量databases 1# 日志logfile /tmp/6379/run.log 将这个文件拷贝到每个目录下： 1234# 进入/tmp目录cd /tmp# 执行拷贝echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf 修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致： 1234# 进入/tmp目录cd /tmp# 修改配置文件printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i &#x27;s/6379/&#123;&#125;/g&#x27; &#123;&#125;/redis.conf 3.3、启动因为已经配置了后台启动模式，所以可以直接启动服务： 1234# 进入/tmp目录cd /tmp# 一键启动所有服务printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf 通过ps查看状态： 1ps -ef | grep redis 发现服务都已经正常启动： 如果要关闭所有进程，可以执行命令： 1ps -ef | grep redis | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill 或者（推荐这种方式）： 1printf &#x27;%s\\n&#x27; 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown 3.4、创建集群虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。 我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。 1）Redis5.0之前 Redis5.0之前集群命令都是用redis安装包下的src&#x2F;redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。 123# 安装依赖yum -y install zlib ruby rubygemsgem install redis 然后通过命令来管理集群： 1234# 进入redis的src目录cd /tmp/redis-6.2.4/src# 创建集群./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 2）Redis5.0以后 我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下： 1redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003 命令说明： redis-cli –cluster 或者 .&#x2F;redis-trib.rb：代表集群操作命令 create ：代表是创建集群 –replicas 1 或者 –cluster-replicas 1 ：指定集群中每个master的副本个数为1，此时 节点总数 ÷ (replicas + 1) 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master 运行后的样子： 这里输入yes，则集群开始创建： 通过命令可以查看集群状态： 1redis-cli -p 7001 cluster nodes 3.5、测试尝试连接7001节点，存储一个数据： 12345678# 连接redis-cli -p 7001# 存储数据set num 123# 读取数据get num# 再次存储set a 1 结果悲剧了： 集群操作时，需要给redis-cli加上-c参数才可以： 1redis-cli -c -p 7001 这次可以了：","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"MySQL主从复制+读写分离","slug":"MySQL主从复制+读写分离","date":"2024-08-13T02:34:26.000Z","updated":"2025-11-05T02:13:30.696Z","comments":true,"path":"2024/08/13/MySQL主从复制+读写分离/","permalink":"http://example.com/2024/08/13/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6+%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/","excerpt":"","text":"1、MySQL主从复制MySQL主从复制是一个异步的复制过程，底层是基于Mysql数据库自带的 二进制日志 功能。就是一台或多台MySQL数据库（slave，即从库）从另一台MySQL数据库（master，即主库）进行日志的复制，然后再解析日志并应用到自身，最终实现 从库 的数据和 主库 的数据保持一致。MySQL主从复制是MySQL数据库自带功能，无需借助第三方工具。 二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。默认MySQL是未开启该日志的。 MySQL的主从复制原理如下： MySQL复制过程分成三步： 1). MySQL master 将数据变更写入二进制日志( binary log) 2). slave将master的binary log拷贝到它的中继日志（relay log） 3). slave重做中继日志中的事件，将数据变更反映它自己的数据 1、主库配置1、MySQL 默认加载 my.cnf 123456[mysqld]log-bin=mysql-bin #[必须]启用二进制日志server-id=128 #[必须]服务器唯一ID(唯一即可)expire_logs_days=7max_binlog_size=100M... 12345678docker run --privileged -d -p 3306:3306 \\ -v /data/dockerData/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf \\ -v /data/dockerData/mysql/logs:/logs \\ -v /data/dockerData/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=1234 \\ --name mysql5.7 \\ mysql:5.7 \\ --log-bin=/var/lib/mysql/mysql-bin # 强制启用binlog（确保生效） 2、验证 123456# 进入容器docker exec -it mysql5.7 mysql -uroot -p1234# 查看binlog是否启用show variables like &#x27;log_bin&#x27;;# 查看主库状态show master status; 3、创建数据同步的用户并授权 1GRANT REPLICATION SLAVE ON *.* to &#x27;xiaoming&#x27;@&#x27;%&#x27; identified by &#x27;Root@251314&#x27;; 注：上面SQL的作用是创建一个用户 xiaoming ，密码为 Root@123456 ，并且给xiaoming用户授予REPLICATION SLAVE权限。常用于建立复制时所需要用到的用户权限，也就是slave必须被master授权具有该权限的用户，才能通过该用户复制。 4、登录Mysql数据库，查看master同步状态 执行下面SQL，记录下结果中File和Position的值 1show master status; 注：上面SQL的作用是查看Master的状态，执行完此SQL后不要再执行任何操作 2、从库配置修改Mysql数据库的配置文件&#x2F;etc&#x2F;my.cnf 1server-id=201 #[必须]服务器唯一ID 1234567docker run --privileged -d -p 3306:3306 \\ -v /data/dockerData/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf \\ -v /data/dockerData/mysql/logs:/logs \\ -v /data/dockerData/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=1234 \\ --name mysql5.7 \\ mysql:5.7 登录Mysql数据库，设置主库地址及同步位置 12345678# 进入容器docker exec -it mysql5.7 mysql -uroot -p1234stop slave;change master to master_host=&#x27;192.168.60.128&#x27;,master_user=&#x27;xiaoming&#x27;,master_password=&#x27;Root@251314&#x27;,master_log_file=&#x27;mysql-bin.000002&#x27;,master_log_pos=154;start slave; 参数说明： ​ A. master_host : 主库的IP地址 ​ B. master_user : 访问主库进行主从复制的用户名(上面在主库创建的) ​ C. master_password : 访问主库进行主从复制的用户名对应的密码 ​ D. master_log_file : 从哪个日志文件开始同步(上述查询master状态中展示的有) ​ E. master_log_pos : 从指定日志文件的哪个位置开始同步(上述查询master状态中展示的有) 查看从数据库的状态 1show slave status\\G MySQL命令行技巧： ​ \\G : 在MySQL的sql语句后加上\\G，表示将查询结果进行按列打印，可以使每个字段打印到单独的行。即将查到的结构旋转90度变成纵向； 2、读写分离案例对日益增加的系统访问量，数据库的吞吐量面临着巨大瓶颈。 对于同一时刻有大量并发读操作和较少写操作类型的应用系统来说，将数据库拆分为主库和从库，主库负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁，使得整个系统的查询性能得到极大的改善。 Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。 使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离。 用法： 1、在pom.xml中增加shardingJdbc的maven坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt; &lt;artifactId&gt;sharding-jdbc-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;4.0.0-RC1&lt;/version&gt;&lt;/dependency&gt; 2、在application.yml中增加数据源的配置 12345678910111213141516171819202122232425262728293031spring: shardingsphere: datasource: names: master,slave # 主数据源 master: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.138.100:3306/rw?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: root # 从数据源 slave: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.138.101:3306/rw?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: root masterslave: # 读写分离配置 load-balance-algorithm-type: round_robin #轮询 # 最终的数据源名称 name: dataSource # 主库数据源名称 master-data-source-name: master # 从库数据源名称列表，多个逗号分隔 slave-data-source-names: slave props: sql: show: true #开启SQL显示，默认false","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"SpringCache框架的使用","slug":"SpringCache框架的使用","date":"2024-08-08T02:27:30.000Z","updated":"2025-11-04T03:35:32.336Z","comments":true,"path":"2024/08/08/SpringCache框架的使用/","permalink":"http://example.com/2024/08/08/SpringCache%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SpringCache框架的使用1、注解 注解 说明 @EnableCaching 开启缓存注解功能 @Cacheable 在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 @CachePut 将方法的返回值放到缓存中 @CacheEvict 将一条或多条数据从缓存中删除 2、导入坐标使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; application.yml 123456789spring: redis: host: 192.168.200.200 port: 6379 password: root@123456 database: 0 cache: redis: time-to-live: 1800000 #设置缓存过期时间，可选 3、注解应用@CachePut注解@CachePut 说明： ​ 作用: 将方法返回值，放入缓存 ​ value: 缓存的名称, 每个缓存名称下面可以有很多key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 1234567891011/*** CachePut：将方法返回值放入缓存* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@CachePut(value = &quot;userCache&quot;, key = &quot;#user.id&quot;)@PostMappingpublic User save(User user)&#123; userService.save(user); return user;&#125; key的写法如下： ​ #user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ; ​ #user.name: #user指的是方法形参的名称, name指的是user的name属性 ,也就是使用user的name属性作为key ; ​ #result.id : #result代表方法返回值，该表达式 代表以返回对象的id属性作为key ； ​ #result.name : #result代表方法返回值，该表达式 代表以返回对象的name属性作为key ； @CacheEvict注解@CacheEvict 说明： ​ 作用: 清理指定缓存 ​ value: 缓存的名称，每个缓存名称下面可以有多个key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 123456789101112131415161718192021222324/*** CacheEvict：清理指定缓存* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0&quot;) //#p0 代表第一个参数//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0]&quot;) //#root.args[0] 代表第一个参数//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#id&quot;) //#id 代表变量名为id的参数@DeleteMapping(&quot;/&#123;id&#125;&quot;)public void delete(@PathVariable Long id)&#123; userService.removeById(id);&#125;//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#p0.id&quot;) //第一个参数的id属性//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#user.id&quot;) //参数名为user参数的id属性//@CacheEvict(value = &quot;userCache&quot;,key = &quot;#root.args[0].id&quot;) //第一个参数的id属性@CacheEvict(value = &quot;userCache&quot;,key = &quot;#result.id&quot;) //返回值的id属性@PutMappingpublic User update(User user)&#123; userService.updateById(user); return user;&#125; @Cacheable注解@Cacheable 说明: ​ 作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 ​ value: 缓存的名称，每个缓存名称下面可以有多个key ​ key: 缓存的key ———-&gt; 支持Spring的表达式语言SPEL语法 1234567891011/*** Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中* value：缓存的名称，每个缓存名称下面可以有多个key* key：缓存的key*/@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)public User getById(@PathVariable Long id)&#123; User user = userService.getById(id); return user;&#125; 在@Cacheable注解中，提供了两个属性分别为： condition， unless 。 condition : 表示满足什么条件, 再进行缓存 ; unless : 表示满足条件则不缓存 ; 与上述的condition是反向的 ; 12345678910111213/** * Cacheable：在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中 * value：缓存的名称，每个缓存名称下面可以有多个key * key：缓存的key * condition：条件，满足条件时才缓存数据 * unless：满足条件则不缓存 */@Cacheable(value = &quot;userCache&quot;,key = &quot;#id&quot;, unless = &quot;#result == null&quot;)@GetMapping(&quot;/&#123;id&#125;&quot;)public User getById(@PathVariable Long id)&#123; User user = userService.getById(id); return user;&#125; 在list方法上加注解@Cacheable 在list方法中进行查询时，有两个查询条件，如果传递了id，根据id查询； 如果传递了name， 根据name查询，那么我们缓存的key在设计的时候，就需要既包含id，又包含name。 具体的代码实现如下： 123456789@Cacheable(value = &quot;userCache&quot;,key = &quot;#user.id + &#x27;_&#x27; + #user.name&quot;)@GetMapping(&quot;/list&quot;)public List&lt;User&gt; list(User user)&#123; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); queryWrapper.eq(user.getId() != null,User::getId,user.getId()); queryWrapper.eq(user.getName() != null,User::getName,user.getName()); List&lt;User&gt; list = userService.list(queryWrapper); return list;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"}]},{"title":"cfssl工具制作证书","slug":"cfssl工具制作证书","date":"2024-07-01T05:35:02.000Z","updated":"2025-11-05T02:13:50.628Z","comments":true,"path":"2024/07/01/cfssl工具制作证书/","permalink":"http://example.com/2024/07/01/cfssl%E5%B7%A5%E5%85%B7%E5%88%B6%E4%BD%9C%E8%AF%81%E4%B9%A6/","excerpt":"","text":"cfssl工具制作证书安装cfssl[去git下载二进制文件]: https://github.com/cloudflare/cfssl/releases “点击下载文件” 下载文件 1cfssl_1.6.5_linux_amd64 cfssl-certinfo_1.6.5_linux_amd64 cfssljson_1.6.5_linux_amd64 123456# 赋权限$ chmod +x cffs*# 移动到 /usr/local/bin$ mv cfssl_1.6.1_linux_amd64 /usr/local/bin/cfssl$ mv cfssl-certinfo_1.6.1_linux_amd64 /usr/local/bin/cfssl-certinfo$ mv cfssljson_1.6.1_linux_amd64 /usr/local/bin/cfssljson 生成根证书12345678910111213141516171819202122# 根证书请求配置文件$ vim ca-csr.json&#123; &quot;CN&quot;: &quot;ltdw&quot;, &quot;key&quot;: &#123; &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 &#125;, &quot;names&quot;: [&#123; &quot;C&quot;: &quot;CN&quot;, &quot;ST&quot;: &quot;Beijing&quot;, &quot;L&quot;: &quot;beijing&quot;, &quot;O&quot;: &quot;ltdw&quot;, &quot;OU&quot;: &quot;ltdw&quot; &#125;]&#125;# 生成证书$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca# -base ca 指定生成的证书名称 CN 证书名称 C Country， 国家 L Locality，地区，城市 O Organization Name，组织名称，公司名称 OU Organization Unit Name，组织单位名称，公司部门 ST State，州，省 通过ca签发服务器证书1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 服务器证书请求配置文件vim 192.168.1.101-csr.json&#123; &quot;CN&quot;: &quot;192.168.1.101&quot;, &quot;hosts&quot;: [ &quot;192.168.1.101&quot;, &quot;kube-master&quot; ], &quot;key&quot;: &#123; &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 &#125;, &quot;names&quot;: [ &#123; &quot;C&quot;: &quot;CN&quot;, &quot;L&quot;: &quot;BeiJing&quot;, &quot;ST&quot;: &quot;BeiJing&quot;, &quot;O&quot;: &quot;ltdw&quot;, &quot;OU&quot;: &quot;ltdw&quot; &#125; ]&#125;# 生成证书策略文件$ cat ca-config.json&#123; &quot;signing&quot;: &#123; &quot;default&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot; &#125;, &quot;profiles&quot;: &#123; &quot;server&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;server auth&quot;, &quot;client auth&quot; ] &#125;, &quot;intermediate&quot;: &#123; &quot;expiry&quot;: &quot;87600h&quot;, &quot;usages&quot;: [ &quot;signing&quot;, &quot;key encipherment&quot;, &quot;cert sign&quot;, &quot;crl sign&quot;, &quot;server auth&quot;, &quot;client auth&quot; ] &#125; &#125; &#125;&#125;# 生成证书$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=intermediate 192.168.1.101-csr.json | cfssljson -bare 192.168.1.101# 单独生成csr文件$ cfssl genkey csr.json | cfssljson -bare 192.168.1.101# 证书和私钥合并成pfx$ openssl pkcs12 -export -out certificate.pfx -inkey private_key.pem -in certificate.pem -certfile intermediate_cert.pem# pfx 提取证书和私钥$ openssl pkcs12 -in certificate.pfx -nocerts -nodes -out private_key.pem$ openssl pkcs12 -in certificate.pfx -clcerts -nokeys -out certificate.pem$ openssl verify -CAfile ca.pem intermediate.pem 默认策略，指定了证书的有效期是一年(8760h) usages.signing, 表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA&#x3D;TRUE usages.server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证 usages.client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证 证书格式转换12345# pem &gt; crt$ openssl x509 -in ca.pem -out ca.crt# pem &gt; key$ openssl rsa -in ca.pem -out ca.key 挂载在Linux操作系统中, 把192.168.1.101-key.pem和192.168.1.101.pem 挂载到nginx下 本地计算机安装ca.crt证书 双击-安装证书-本地计算机-将所有证书都放入下列存储-受信任的根证书颁发机构","categories":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/categories/ssl/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"}]},{"title":"yuque-dl","slug":"yuque-dl","date":"2024-05-21T06:59:27.000Z","updated":"2025-11-05T02:14:42.006Z","comments":true,"path":"2024/05/21/yuque-dl/","permalink":"http://example.com/2024/05/21/yuque-dl/","excerpt":"","text":"语雀文档下载到本地1.下载nodejs 点此直接下载Node.js v22.13.1 去官网查看： 1https://nodejs.org/zh-cn 2.win+r打开运行，输入cmd打开命令提示符 3.更换镜像源 12npm config get registry npm config set registry https://registry.npmmirror.com 4.安装插件 1npm i -g yuque-dl 5.查看是否下载完成 1yuque-dl --help 6.下载文档 yuque-dl 示例： 1yuque-dl &quot;https://www.yuque.com/yuque/thyzgp&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 修改默认路径 在cmd里输入以下命令 mklink&#x2F;J “C:\\Users\\你的用户名\\download” “目标位置” 例如： 1mklink/J &quot;C:\\Users\\hp\\download&quot; &quot;D:\\download&quot; 当显示：为xxx&lt;&lt;&#x3D;&#x3D;&#x3D;&gt;&gt;xxx创建的连接即可 然后正常下载 7、出现下面图片中报错的情况的，按下面的方法解决 私有知识库通过别人私有知识库 分享的链接，需使用-t添加token才能下载 1yuque-dl &quot;https://www.yuque.com/yuque/thyzgp&quot; -t &quot;abcd...&quot; 公开密码访问的知识库⚠️ 公开密码访问的知识库两种情况: 已经登录语雀，访问需要密码的知识库 输入密码后使用_yuque_session这个cookie 1yuque-dl &quot;url&quot; -t &quot;_yuque_session的值&quot; 未登录语雀，访问需要密码的知识库 输入密码后需要使用verified_books&#x2F;verified_docs这个cookie 1yuque-dl &quot;url&quot; -k &quot;verified_books&quot; -t &quot;verified_books的值&quot; 内置启动web服务可快速预览使用vitepress快速启动一个web服务提供可预览下载的内容 1234yuque-dl server ./download/知识库/➜ Local: http://localhost:5173/➜ Network: use --host to expose","categories":[{"name":"cmd","slug":"cmd","permalink":"http://example.com/categories/cmd/"}],"tags":[{"name":"语雀","slug":"语雀","permalink":"http://example.com/tags/%E8%AF%AD%E9%9B%80/"}]},{"title":"MySQL常见数据类型","slug":"MySQL常见数据类型","date":"2024-04-05T02:12:54.000Z","updated":"2025-11-05T02:20:27.322Z","comments":true,"path":"2024/04/05/MySQL常见数据类型/","permalink":"http://example.com/2024/04/05/MySQL%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"MySQL常见数据类型MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。 1、数值类型 类型 大小 有符号(SIGNED)范围 无符号(UNSIGNED)范围 描述 TINYINT 1byte (-128，127) (0，255) 小整数值 SMALLINT 2bytes (-32768，32767) (0，65535) 大整数值 MEDIUMINT 3bytes (-8388608，8388607) (0，16777215) 大整数值 INT&#x2F;INTEGER 4bytes (-2147483648，2147483647) (0，4294967295) 大整数值 BIGINT 8bytes (-2^63，2^63-1) (0，2^64-1) 极大整数值 FLOAT 4bytes (-3.402823466 E+38，3.402823466351 E+38) 0 和 (1.175494351 E-38，3.402823466 E+38) 单精度浮点数值 DOUBLE 8bytes (-1.7976931348623157 E+308，1.7976931348623157 E+308) 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) 双精度浮点数值 DECIMAL 依赖于M(精度)和D(标度)的值 依赖于M(精度)和D(标度)的值 小数值(精确定点数) 2、字符串类型 类型 大小 描述 CHAR 0-255 bytes 定长字符串(需要指定长度) VARCHAR 0-65535 bytes 变长字符串(需要指定长度) TINYBLOB 0-255 bytes 不超过255个字符的二进制数据 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性能会更高些。 3、日期时间类型 类型 大小 范围 格式 描述 DATE 3 1000-01-01 至 9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59 至 838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901 至 2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00 至 9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01 至 2038-01-19 03:14:07 YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"使用yum安装wget报错","slug":"使用yum安装wget报错","date":"2024-01-13T08:42:09.000Z","updated":"2025-03-20T07:15:24.315Z","comments":true,"path":"2024/01/13/使用yum安装wget报错/","permalink":"http://example.com/2024/01/13/%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85wget%E6%8A%A5%E9%94%99/","excerpt":"","text":"使用yum安装wget报错使用yum安装报错：Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp; 安装wget命令 1yum -y install wget 报错，无法找到镜像 测试是否是网络问题 抓包正常，网络没有问题；尝试更新yum 又开始报错 尝试分析问题原因出现这个错误是因为使用的 CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了你的 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。 尝试解决： 进入&#x2F;etc&#x2F;yum.repos.d目录下找到 CentOS-Base.rep 执行下面操作 1cp CentOS-Base.repo CentOS-Base.repo.backup 然后修改 CentOS-Base.repo 为 # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-$releasever - Base #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/os/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #released updates [updates] name=CentOS-$releasever - Updates #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/updates/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful [extras] name=CentOS-$releasever - Extras #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra #$baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/extras/$basearch/ gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages [centosplus] name=CentOS-$releasever - Plus #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra #baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/ #baseurl=http://vault.centos.org/7.9.2009/x86_64/os/ baseurl=http://vault.centos.org/7.9.2009/centosplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 wq保存，再执行 12sudo yum clean allsudo yum makecache 等待加载成功，然后继续执行 1curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 然后执行 1cat CentOS-Base.repo 发现镜像已改为了阿里云的 再此尝试导入wget命令 好的成功了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"}]},{"title":"CentOS安装Docker\\Docker-compose","slug":"CentOS安装Docker","date":"2023-12-19T05:53:20.000Z","updated":"2025-03-20T11:59:11.471Z","comments":true,"path":"2023/12/19/CentOS安装Docker/","permalink":"http://example.com/2023/12/19/CentOS%E5%AE%89%E8%A3%85Docker/","excerpt":"","text":"CentOS安装Docker\\Docker-composeCentOS安装Docker1、卸载（可选）如果之前安装过旧版本的Docker，可以使用下面命令卸载： 1234567891011yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine \\ docker-ce 2、安装docker首先需要大家虚拟机联网，安装yum工具 123yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 --skip-broken 然后更新本地镜像源： 12345678910# 设置docker镜像源yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #将所有的 download.docker.com 替换为 mirrors.aliyun.com/docker-cesed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo#输入以下命令来更新 yum 缓存yum makecache fast 然后输入命令： 1yum install -y docker-ce docker-ce为社区免费版本。稍等片刻，docker即可安装成功。 3、启动dockerDocker应用需要用到各种端口，逐一去修改防火墙设置。 这里展示直接关闭防火墙的命令 1234# 关闭systemctl stop firewalld# 禁止开机启动防火墙systemctl disable firewalld 通过命令启动docker： 123456789systemctl start docker # 启动docker服务systemctl stop docker # 停止docker服务systemctl restart docker # 重启docker服务systemctl enable docker # 开机自启docker服务systemctl start docker # 启动docker服务 然后输入命令，可以查看docker版本： 1docker -v 4、配置镜像加速docker官方镜像仓库网速较差，导致拉取镜像失败，如下面这种错误， 1docker pull 报错 Error response from daemon: Get “https://registry-1.docker.io/v2/“ 我们需要设置国内镜像服务： 解决方案如下： 1vi /etc/docker/daemon.json 添加以下内容： 1234567&#123; &quot;data-root&quot;: &quot;/home/docker-root&quot;, &quot;registry-mirrors&quot;: [ &quot;https://registry.dockercn.com&quot;, &quot;https://0mmuy3ea.mirror.aliyuncs.com/&quot;,&quot;https://docker.m.daocloud.io/&quot; ]&#125; 然后保存 1:wq 重启docker 12systemctl daemon-reloadsystemctl restart docker centos安装docker-compose1、最新版本查询Docker Compose 的最新版本会不断更新，你可以通过以下几种方式来查看目前的最新版本： 官方发布页面：访问 Docker Compose 的 GitHub 发布页面，该页面会列出所有的版本信息，页面上显示的最新版本就是目前可获取的最新版本。 命令行查看：如果你已经安装了 Docker Compose，在终端中执行 docker-compose version 命令，就能看到当前安装的版本。要是想知道是否有更新版本，还是要参考官方发布页面。 2、安装最新版本如果要安装最新版本的 Docker Compose，可以参考以下步骤（以 Linux 系统为例）： 1234567891011# 获取最新稳定版本号COMPOSE_VERSION=$(curl -s https://api.github.com/repos/docker/compose/releases/latest | grep &#x27;tag_name&#x27; | cut -d\\&quot; -f4)# 下载指定版本的 Docker Composesudo curl -L &quot;https://github.com/docker/compose/releases/download/$&#123;COMPOSE_VERSION&#125;/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 添加可执行权限sudo chmod +x /usr/local/bin/docker-compose# 验证安装docker-compose --version 上述脚本会自动获取最新版本号并完成 Docker Compose 的下载和安装，最后验证安装是否成功。 3、获取最新版本补全脚本若要使用最新版本的 Docker Compose 补全脚本，你可以把命令中的版本号替换成最新版本。获取最新版本号的方式有多种，例如访问 Docker Compose 的 GitHub 发布页面。 假设你已经得知最新版本是 v2.20.3（实际使用时请替换为真正的最新版本），可以使用如下命令获取对应版本的补全脚本： 1sudo curl -L https://raw.githubusercontent.com/docker/compose/v2.20.3/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 运行完该命令后，重新打开一个终端让补全功能生效。 4、当使用命令无法安装时，可以下载源文件进行安装，步骤如下：当你下载了 compose-2.34.0.tar.gz 文件后，通常意味着你下载的是 Docker Compose 的源码包，下面为你介绍安装 Docker Compose 的操作步骤： 1. 解压文件你需要使用 tar 命令来解压下载的 compose-2.34.0.tar.gz 文件。在终端中执行以下命令： bash 1tar -zxvf compose-2.34.0.tar.gz 该命令会将压缩包解压到当前目录下，解压后会生成一个名为 compose-2.34.0 的文件夹。 2. 进入解压后的目录使用 cd 命令进入解压后的文件夹： bash 1cd compose-2.34.0 3. 构建并安装 Docker Compose一般情况下，你可以使用 make 命令来构建和安装 Docker Compose。不过在执行 make 命令之前，需要确保你的系统已经安装了 make 工具和其他必要的依赖项。执行以下命令： bash 12makesudo make install make 命令会根据 Makefile 文件中的规则来编译和构建 Docker Compose。 sudo make install 命令会将构建好的二进制文件安装到系统中，使其可以在全局范围内使用。 4. 验证安装安装完成后，你可以使用以下命令来验证 Docker Compose 是否安装成功： bash 1docker-compose --version 如果输出显示 Docker Compose 的版本为 2.34.0，则说明安装成功。 可能遇到的问题及解决办法 缺少依赖项：如果在执行 make 命令时出现错误，提示缺少某些依赖项，你需要安装这些依赖项。常见的依赖项包括 go 语言环境等。你可以根据错误提示安装相应的依赖项。 权限问题：如果在执行 sudo make install 命令时遇到权限问题，确保你具有足够的权限。通常使用 sudo 命令可以解决权限问题。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"hexo搭建博客","slug":"博客制作","date":"2023-11-25T10:48:45.000Z","updated":"2025-03-20T11:59:32.122Z","comments":true,"path":"2023/11/25/博客制作/","permalink":"http://example.com/2023/11/25/%E5%8D%9A%E5%AE%A2%E5%88%B6%E4%BD%9C/","excerpt":"","text":"hexo搭建博客第一部分Hexo简介Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。 Hexo搭建步骤 安装Git 安装Node.js 安装Hexo GitHub创建个人仓库 生成SSH添加到GitHub 将hexo部署到GitHub 设置个人域名 发布文章 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。 Windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。 Linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码 1sudo apt-get install git 安装好后，用git --version 来查看一下版本 2. 安装nodejsHexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。 windows：nodejs选择LTS版本就行了。 linux： 12sudo apt-get install nodejssudo apt-get install npm 安装完后，打开命令行 12node -vnpm -v 检查一下有没有安装成功 顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。 3. 安装hexo****前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 1npm install -g hexo-cli 依旧用hexo -v查看一下版本 至此就全部安装完了。 接下来初始化一下hexo 1hexo init myblog 这个myblog可以自己取什么名字都行，然后 12cd myblog //进入这个myblog文件夹npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题 ** _config.yml: 博客的配置文件** 12hexo ghexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 使用ctrl+c可以把服务关掉。 4. GitHub创建个人仓库首先，你先要有一个GitHub账户，去注册一个吧。 注册完登录后，在GitHub.com中看到一个New repository，新建仓库 创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。 点击create repository。 5. 生成SSH添加到GitHub回到你的git bash中， 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。 12git config user.namegit config user.email 然后创建SSH,一路回车 1ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把你的id_rsa.pub里面的信息复制进去。 在gitbash中，查看是否成功 1ssh -T git@github.com 6. 将hexo部署到GitHub这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为YourgithubName就是你的GitHub账户 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 1npm install hexo-deployer-git --save 然后 123hexo cleanhexo generatehexo deploy 其中 hexo clean清除了你之前生成的东西，也可以不加。hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写hexo deploy 部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！ 接下来你就可以正式开始写文章了。 1hexo new newpapername 然后在source&#x2F;_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再 123hexo cleanhexo ghexo d 就可以看到更新了。 第二部分hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。 1. hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。网址 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 永久链接 。 再往下翻，中间这些都默认就好了。 12345678theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;repository url&gt; branch: [branch] theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。 接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。 Front-matterFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 123title: Hello Worlddate: 2013/7/13 20:46:25--- 下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games layout（布局）当你每一次使用代码 1hexo new paper 它其实默认使用的是post这个布局，也就是在source文件夹下的_post里面。 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 而new这个命令其实是： 1hexo new [layout] &lt;title&gt; 只不过这个layout默认是post罢了。 page如果你想另起一页，那么可以使用 1hexo new page board 系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是http://xxx.xxx/board draftdraft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以 1hexo new draft newpage 这样会在source&#x2F;_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用 1hexo server --draft 在本地端口中开启服务预览。 如果你的草稿文件写完了，想要发表到post中， 1hexo publish draft newpage 就会自动把newpage.md发送到post中。 2. 更换主题到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。点这里 直接在github链接上下载下来，然后放到theme文件夹下就行了，然后再在刚才说的配置文件中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。 而后进入hueman这个文件夹，可以看到里面也有一个配置文件_config.xml，貌似它默认是_config.xml.example，把它复制一份，重命名为_config.xml就可以了。这个配置文件是修改你整个主题的配置文件。 3. git分支进行多终端工作问题来了，如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？ 在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。 机制机制是这样的，由于hexo d上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。 也就是上传的是在本地目录里自动生成的.deploy_git里面。 其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github 所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。 上传分支首先，先在github上新建一个hexo分支，如图： 然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。 然后在本地的任意目录下，打开git bash， 1git clone git@github.com:xxxxx-hub/xxxxxx.github.io.git 将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。 接下来在克隆到本地的ZJUFangzh.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git。这里应该说一句，复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。 而后 123git add .git commit –m &quot;add branch&quot;git push 这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中node_modules、public、db.json已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。 这样就上传完了。 更换电脑操作一样的，跟之前的环境搭建一样， 安装git 1sudo apt-get install git 设置git全局邮箱和用户名 12git config --global user.name &quot;yourgithubname&quot;git config --global user.email &quot;yourgithubemail&quot; 设置ssh key 12345ssh-keygen -t rsa -C &quot;youremail&quot;#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话) 安装nodejs 12sudo apt-get install nodejssudo apt-get install npm 安装hexo 1sudo npm install hexo-cli -g 但是已经不需要初始化了， 直接在任意文件夹下， 1git clone git@……………… 然后进入克隆到的文件夹： 123cd xxx.github.ionpm installnpm install hexo-deployer-git --save 生成，部署： 12hexo ghexo d 然后就可以开始写你的新博客了 1hexo new newpage Tips: 不要忘了，每次写完最好都把源文件上传一下 123git add .git commit –m &quot;xxxx&quot;git push 如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了 1git pull","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"github配置ssh秘钥","slug":"github配置ssh秘钥","date":"2023-11-06T01:47:21.000Z","updated":"2025-11-06T02:00:00.782Z","comments":true,"path":"2023/11/06/github配置ssh秘钥/","permalink":"http://example.com/2023/11/06/github%E9%85%8D%E7%BD%AEssh%E7%A7%98%E9%92%A5/","excerpt":"","text":"github配置ssh秘钥第一步：在 PowerShell 中，使用1dir ~\\.ssh\\ 1~ 在 PowerShell 中代表你的用户目录，比如 `C:\\Users\\18713 示例输出如果已有 SSH 密钥，你会看到类似： 123456Mode LastWriteTime Length Name---- ------------- ------ -----a---- 2025/11/4 11:30 411 id_ed25519-a---- 2025/11/4 11:30 102 id_ed25519.pub-a---- 2025/11/4 11:34 831 known_hosts-a---- 2025/11/3 18:11 92 known_hosts.old 如果没有 .ssh 文件夹，会提示： 1Get-ChildItem: 找不到路径“C:\\Users\\18713\\.ssh”，因为该路径不存在。 第二步：如果没有 .ssh 文件夹或密钥 → 生成一个！ 算法 公钥 私钥 ED25519（首选） id_ed25519.pub id_ed25519 RSA（至少 2048 位密钥大小） id_rsa.pub id_rsa 在 PowerShell 中运行（推荐 ed25519 算法）： 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 生成2048位RSA 1ssh-keygen -t rsa -b 2048 -C &quot;your_email@example.com&quot; 文件生成到 ~/.ssh/ 目录 把 your_email@example.com 换成你 GitHub 账号注册的邮箱 然后按三次回车（使用默认路径和空密码）： 123Enter file in which to save the key (~/.ssh/id_ed25519):Enter passphrase (empty for no passphrase):Enter same passphrase again: 完成后，再运行： 1dir ~\\.ssh\\ 你应该就能看到 id_ed25519 和 id_ed25519.pub 了。 启动 ssh-agent 服务： 1Start-Service ssh-agent 添加私钥到 agent： 1ssh-add ~\\.ssh\\id_ed25519 第三步：把公钥内容添加到 GitHub你现在需要把 公钥（.pub 文件）的内容复制到 GitHub 上。 1. 复制公钥内容powershell 1Get-Content ~/.ssh/id_ed25519.pub 或者： powershell 1cat ~/.ssh/id_ed25519.pub 你会看到一长串文本，类似： 1ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG... your_email@example.com 👉 全选并复制这一整行（包括开头 ssh-ed25519 和结尾邮箱）。 2. 添加到 GitHub 打开浏览器，登录 GitHub 点右上角头像 → Settings 左侧菜单选 SSH and GPG keys → 点击 New SSH key 填写： Title: 比如 My Windows PC Key type: 选 Authentication Key: 粘贴你刚刚复制的那整行公钥 点击 Add SSH key 第四步：再次测试连接1ssh -T git@github.com 正确响应应该是： 1Hi zhangzc-hub! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 这说明你已经通过 SSH 认证成功，现在可以正常使用 git pull, git push 了！","categories":[{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-10-24T10:48:45.000Z","updated":"2025-03-20T07:14:37.563Z","comments":true,"path":"2023/10/24/hello-world/","permalink":"http://example.com/2023/10/24/hello-world/","excerpt":"","text":"Hello World: 第一步，从这里开始​ 大家好，我是ZC，一名热衷于探索技术世界的程序员。今天，我怀着激动的心情写下我的第一篇博客。为什么选择“Hello World”作为开篇呢？这不仅仅是因为它几乎是每个程序员学习编程语言时的第一个程序，更因为它象征着我们与计算机世界的初次对话——简单、纯粹且充满无限可能。 编程之路的起点​ 回想起自己第一次在屏幕上敲出“Hello World”的那一刻，那种成就感至今仍然记忆犹新。那时的我对编程充满了好奇与敬畏，不知道接下来的学习之旅将会遇到什么样的挑战。随着时间的推移，我逐渐意识到，每一次代码的编写都是一次创造的过程，而每一个BUG的解决则像是一次小小的胜利。在这个过程中，我学会了如何用逻辑思考问题，如何将复杂的任务分解成可管理的部分，更重要的是，我学会了坚持不懈。 技术分享的意义​ 创建这个博客的目的，不仅仅是记录下我个人的技术成长历程，更是希望能够成为一个交流的平台。在这里，无论是初学者还是经验丰富的开发者，都可以找到有价值的信息，相互启发，共同进步。我相信，通过分享我们的知识、经验和见解，可以激发更多人的创造力，推动整个社区向前发展。 未来的展望​ 展望未来，我希望能够在这个博客上分享更多关于编程技巧、项目开发经验以及对最新技术趋势的思考。同时，我也期待着能够听到读者们的声音，无论是建议、批评还是鼓励，都是我不断前进的动力。让我们一起在这个数字世界中探索未知，创造价值。 ​ 最后，再次感谢您花时间阅读我的第一篇博客。如果您对编程有任何疑问或兴趣，欢迎随时留言交流。希望我们都能在技术的道路上越走越远，直到有一天，我们可以自豪地说：“Look what we’ve built!”","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"ssl","slug":"ssl","permalink":"http://example.com/categories/ssl/"},{"name":"cmd","slug":"cmd","permalink":"http://example.com/categories/cmd/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"},{"name":"git","slug":"git","permalink":"http://example.com/categories/git/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/categories/Hello-World/"}],"tags":[{"name":"若依","slug":"若依","permalink":"http://example.com/tags/%E8%8B%A5%E4%BE%9D/"},{"name":"redis","slug":"redis","permalink":"http://example.com/tags/redis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"ssl","slug":"ssl","permalink":"http://example.com/tags/ssl/"},{"name":"语雀","slug":"语雀","permalink":"http://example.com/tags/%E8%AF%AD%E9%9B%80/"},{"name":"yum","slug":"yum","permalink":"http://example.com/tags/yum/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://example.com/tags/Hello-World/"}]}